// KILT Blockchain â€“ https://botlabs.org
// Copyright (C) 2019-2023 BOTLabs GmbH

// The KILT Blockchain is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The KILT Blockchain is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// If you feel like getting in touch with us, you can do so at info@botlabs.org

//! Module to deal with cross-chain Merkle proof as generated by the KILT chain.

use did::{did_details::DidPublicKeyDetails, DidVerificationKeyRelationship};
use frame_support::{ensure, RuntimeDebug};
use parity_scale_codec::{Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;
use sp_runtime::traits::Hash;
use sp_std::vec::Vec;
use sp_trie::{verify_trie_proof, LayoutV1};

use crate::{utils::OutputOf, BoundedBlindedValue};

/// Type of a Merkle proof containing DID-related information.
/// The generic types are the following:
/// * `KeyId`: The type of a DID key ID according to the producer's definition.
/// * `AccountId`: The type of an account ID according to the producer's
///   definition.
/// * `BlockNumber`: The type of a block number according to the producer's
///   definition.
/// * `Web3Name`: The type of a web3names according to the producer's
///   definition.
/// * `LinkedAccountId`: The type of a DID-linked account ID according to the
///   producer's definition.
#[derive(Encode, Decode, RuntimeDebug, Clone, Eq, PartialEq, TypeInfo)]
pub struct DidMerkleProof<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> {
	pub blinded: BoundedBlindedValue<u8>,
	pub revealed: Vec<RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>>,
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	DidMerkleProof<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Encode,
	AccountId: Encode,
	BlockNumber: Encode,
	Web3Name: Encode,
	LinkedAccountId: Encode,
{
	/// Verifies the DIP Merkle proof revealing some leaves
	/// representing parts of a KILT DID identity stored on the KILT chain
	/// against a given identity commitment. If cross-chain DID signatures are
	/// not required for the specific use case, this verifier can also be used
	/// on its own, without any DID signature verification.
	/// The Merkle proof is assumed to have been generated using one of the
	/// versioned identity commitment generators, as shown in the [KILT runtime
	/// definitions](../../../runtimes/common/src/dip/README.md). The function
	/// returns the revealed leaves if the Merkle proof is correct and if the
	/// number of leaves does not exceed the maximum configured. The generic
	/// types are the following:
	/// * `Hasher`: The hasher used by the producer to hash the Merkle leaves
	///   and produce the identity commitment.
	pub fn verify_against_commitment<Hasher>(
		self,
		commitment: &OutputOf<Hasher>,
		max_leaves_revealed: usize,
	) -> Result<
		impl IntoIterator<Item = RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>>,
		DidMerkleProofVerificationError,
	>
	where
		Hasher: Hash,
	{
		let mut revealed_keys = self.revealed.iter().take(max_leaves_revealed);
		// If there are more keys than MAX_LEAVES_REVEALED, bail out.
		ensure!(
			revealed_keys.next().is_none(),
			DidMerkleProofVerificationError::TooManyLeaves,
		);
		let proof_leaves_key_value_pairs: Vec<(Vec<u8>, Option<Vec<u8>>)> = revealed_keys
			.by_ref()
			.map(|revealed_leaf| (revealed_leaf.encoded_key(), Some(revealed_leaf.encoded_value())))
			.collect();

		verify_trie_proof::<LayoutV1<Hasher>, _, _, _>(commitment, &self.blinded, &proof_leaves_key_value_pairs)
			.map_err(|_| DidMerkleProofVerificationError::InvalidMerkleProof)?;

		Ok(self.revealed)
	}
}

/// Relationship of a key to a DID Document.
#[derive(Clone, Copy, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo, PartialOrd, Ord, MaxEncodedLen)]
pub enum DidKeyRelationship {
	Encryption,
	Verification(DidVerificationKeyRelationship),
}

impl From<DidVerificationKeyRelationship> for DidKeyRelationship {
	fn from(value: DidVerificationKeyRelationship) -> Self {
		Self::Verification(value)
	}
}

impl TryFrom<DidKeyRelationship> for DidVerificationKeyRelationship {
	type Error = ();

	fn try_from(value: DidKeyRelationship) -> Result<Self, Self::Error> {
		if let DidKeyRelationship::Verification(rel) = value {
			Ok(rel)
		} else {
			Err(())
		}
	}
}

/// All possible Merkle leaf types that can be revealed as part of a DIP
/// identity Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, Eq, PartialOrd, Ord, RuntimeDebug, TypeInfo)]
pub enum RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> {
	DidKey(RevealedDidKey<KeyId, BlockNumber, AccountId>),
	Web3Name(RevealedWeb3Name<Web3Name, BlockNumber>),
	LinkedAccount(RevealedAccountId<LinkedAccountId>),
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedDidKey<KeyId, BlockNumber, AccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedDidKey<KeyId, BlockNumber, AccountId>) -> Self {
		Self::DidKey(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedWeb3Name<Web3Name, BlockNumber>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedWeb3Name<Web3Name, BlockNumber>) -> Self {
		Self::Web3Name(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedAccountId<LinkedAccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedAccountId<LinkedAccountId>) -> Self {
		Self::LinkedAccount(value)
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> Default
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Default,
	BlockNumber: Default,
{
	fn default() -> Self {
		RevealedDidKey {
			id: KeyId::default(),
			relationship: DidVerificationKeyRelationship::Authentication.into(),
			details: DidPublicKeyDetails {
				key: did::did_details::DidVerificationKey::Ed25519(sp_core::ed25519::Public::from_raw([0u8; 32]))
					.into(),
				block_number: BlockNumber::default(),
			},
		}
		.into()
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Encode,
	Web3Name: Encode,
	LinkedAccountId: Encode,
{
	pub fn encoded_key(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { id, relationship, .. }) => (id, relationship).encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { web3_name, .. }) => web3_name.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(RevealedAccountId(account_id)) => account_id.encode(),
		}
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	AccountId: Encode,
	BlockNumber: Encode,
{
	pub fn encoded_value(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { details, .. }) => details.encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { claimed_at, .. }) => claimed_at.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(_) => ().encode(),
		}
	}
}

/// The details of a DID key after it has been successfully verified in a Merkle
/// proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, PartialOrd, Ord, RuntimeDebug, TypeInfo)]
pub struct RevealedDidKey<KeyId, BlockNumber, AccountId> {
	/// The key ID, according to the provider's definition.
	pub id: KeyId,
	/// The key relationship to the subject's DID Document.
	pub relationship: DidKeyRelationship,
	/// The details of the DID Key, including its creation block number on the
	/// provider chain.
	pub details: DidPublicKeyDetails<BlockNumber, AccountId>,
}

/// The details of a web3name after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, PartialOrd, Ord, RuntimeDebug, TypeInfo)]
pub struct RevealedWeb3Name<Web3Name, BlockNumber> {
	/// The web3name.
	pub web3_name: Web3Name,
	/// The block number on the provider chain in which it was linked to the DID
	/// subject.
	pub claimed_at: BlockNumber,
}

/// The details of an account after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, PartialOrd, Ord, RuntimeDebug, TypeInfo)]
pub struct RevealedAccountId<AccountId>(pub AccountId);

pub enum DidMerkleProofVerificationError {
	InvalidMerkleProof,
	TooManyLeaves,
}
