// KILT Blockchain â€“ https://botlabs.org
// Copyright (C) 2019-2023 BOTLabs GmbH

// The KILT Blockchain is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The KILT Blockchain is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// If you feel like getting in touch with us, you can do so at info@botlabs.org

//! Module to deal with cross-chain Merkle proof as generated by the KILT chain.
use did::{
	did_details::{DidPublicKey, DidPublicKeyDetails},
	DidSignature, DidVerificationKeyRelationship,
};
use frame_support::{ensure, RuntimeDebug};
use pallet_dip_provider::IdentityCommitmentOf;
use parity_scale_codec::{Codec, Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;
use sp_core::{ConstU32, U256};
use sp_runtime::{
	generic::Header,
	traits::{AtLeast32BitUnsigned, Hash, Header as HeaderT, MaybeDisplay, Member},
	BoundedVec, SaturatedConversion,
};
use sp_std::vec::Vec;
use sp_trie::{verify_trie_proof, LayoutV1};

use crate::{
	state_proofs::{verify_storage_value_proof, verify_storage_value_proof_by_trimming_result, MerkleProofError},
	traits::{BenchmarkDefault, GetWithArg},
	utils::{
		calculate_dip_identity_commitment_storage_key_for_runtime, calculate_parachain_head_storage_key,
		BoundedBlindedValue, OutputOf,
	},
};

// Generated proof for benchmarks
//
// identifier: AccountId32
// gJmtkLQK1Zd9haeYgaHpW93jyqYY9bsq2iyaeTy9jRRuD88PT
// gJmtkLQK1Zd9haeYgaHpW93jyqYY9bsq2iyaeTy9jRRuD88PT
// proof: KiltDipPrimitivesVerifierParachainVersionedDipParachainStateProof
// V0
// V0: KiltDipPrimitivesMerkleV0ParachainDipDidProof
// providerHeadProof: KiltDipPrimitivesMerkleV0ProviderHeadStateProof
// relayBlockNumber: u32
// 1,997
// proof: KiltDipPrimitivesUtilsBoundedBlindedValue
// 0: Bytes: Bytes
// 0x3703f5a4efb16ffa83d0070000c2ae60fbed0585c477cb135b300417d9b33ac2b12930d39a33004836e26b838f
// 1: Bytes: Bytes
// 0x8004648031b60c9237ed343094831987f2bec10b211621255ad0b440cf161fa820d30db480f6f6801e4b41e2e6d8ec194dba122bfb9eb33feb2545ef5144cea79551f7cc52802b87106e5d111981f65f00df77f9d9d3afe53eb23cc96ec4d353725a1891cebc805a1ca4e6e2fd0ce21dd7f10cc3f6139ba0ba0c40ad67ab5d113b9ecbdea20a1d
// 2: Bytes: Bytes
// 0x80ffff80e966b4a51da9c38a0d7a17e2b723f71efacab400bec8e87b583fbfce846f4686802ed46913321a946188d1cb8508840cdf05b7708090f511ccd727e2b14489d04e808f079db43801c8a218194d926976b966e83bfded30d6855170eeeb96d963b57b803f310b27a676c1bb4fb58f1b5077f0532b807babc8f558ff7d08ac5274fcc05f80e8a546dd4e4018432f50ad44f64669c299d69b2a98866105380aea2414349c51805a975984c2e64fe563f2ea4a43245e819ac070ff916f1ec44c8c8b934d9aa2a0806d11e35d372cfbd46f2bcdd8c3b4a1bb13980ef6810e91dca2dc08ce10d20c45805b682132c52908705526057f73ab7fccab4af6d72a9805634dd8d3cc53f130d180c2d44d371e5fc1f50227d7491ad65ad049630361cefb4ab1844831237609f08380ae2023422f1c55fb819e282a938504cc8d90c68c0d7acdaeadd0ed6297e7d40280133104012867a78b358647395ac13e1412fcb0b72f7b19f435154c75691c36cd80b34b48de41388ce68d917e46edd40d956a7a721195549e0fb75db8a06c42b78180cf7db70d0ee865665119f3f4e5b22743894a76ad26106b5317df1fcfc70881418062d153a0609ef4261b9ba7ca0a669346427e70d0c8318775f6715fdbcba92fe5806bfdbbf0e0bedcb993b65c9cea1e929a56d78a3b7bc53d1b7ca6fc488e2295ee8021ac3c1b404e19b37fb968698050b2a0fa7793c9c435933115c7471320f0a296
// 3: Bytes: Bytes
// 0x810355d3847f7f698744d85a58d953a2519d161d098cae9351077f1b58b097e3a1aaf10566b97151d5dfd2625b747fab301e005ae39e09c5809e36c4271372dd49c78a1afddcbc6351a7f5f6b864e4dbfc1f24bf2a6886f84bffd271b437561072db7d990c066175726120f0bd7a08000000000452505352881c64c8e5182d5528c8992a4e2537c141cd921bba3f563aef9c7f0a1973725ee42d1f05617572610101ea097c9fd019abd68eed80cae0fc2455221038a17fca42d0e3eee64c97cc541b5d97f79fbc4472eb758a88f2dc1b44c8c1fb28436c07807a600e8608952f0b87
// 4: Bytes: Bytes
// 0x9e710b30bd2eab0352ddcc26417aa1945fc3803b3441f15daa8a53147d69c48eac75356fab581febbb8030520b248c5942a1488065a87ac86e9a534f260c67ba9ffd20b7f8c84af8048b45706d59b300d43d7e358022045e2f19a1ea70aebae1c5e0d528b5019a843615c87ecb11c765877ff0d347804d1bcb912779eee5bff60692ff6d4fd0ab96b0dd0294fa28c8f9b3984c69fe80505f0e7b9012096b41c4eb3aaf947f6ea4290800004c5f03c716fb8fff3de61a883bb76adb34a2040080a7779f25a1b57328ce4afc3c851952c6f6e1097c75f14acd39c1d6ee86f247b24c5f0f4993f016e2d2f8e5f43be7bb25948604008087b6d4dd1bdb69335b70a68091e04d32b436b067f3931d8bc6aceacc60b6d64580e69805df2dc25f914f1daf037fca347ecbbafa95e294e38fa39fb1ad8d4b9b71
// 5: Bytes: Bytes
// 0x9f0b3c252fcb29d88eff4f3de5de4476c350008075845b7ee7bab46d15a478a4fec28d331e7914b8680715054e8cf2331557814980aa529bc8f034b33c7223e9c7dbbda60fae5d6a4c085c6adc6d245a91501efd19
// dipCommitmentProof: KiltDipPrimitivesMerkleV0DipCommitmentStateProof
// 0: Bytes: Bytes
// 0x7f23c9910d53bd2ec30683f23efae459a54bf7c150bbd5e42b7556cfa979119831e68a75190627034801a12dfa1fa4ab9a000080f81928d7d682c551d711cc11c6231b606a399aa4e217419b0c6d4a6573262d24
// 1: Bytes: Bytes
// 0x800c8080da28793d083b197f8d92fc3e77f5064436f1d8eea0fbea56ddb936aba6544500800401aa8c1be1f4573121c94c4d6814351c3b923466beca78b7e873d50abd04ce803cb3d55f2a6abf431574cd6fd17415a88d4377367e25576cd44d9ac9966c01a8
// 2: Bytes: Bytes
// 0x80842080e706734dc2654f4024bc1f3444d00996ea913e91d8754940f4d0dc4df38678b6805223fb8a384fc6473e3a7b780e772b386efd0a50c16de03daf5ce0fbf2f426e6803721a908af5c896ce92051f9d1eec7ff3f1b6814ece08c609869ae99a0fe9281
// 3: Bytes: Bytes
// 0x80ffff80353e4d164b13c87910044f1b4e76277e404a0ab46a7cd6c33a65aaadc2375ba88007b1390da34b4dce1328430fd924a6e193517a8148dd70a912c0dc2f7f8d2d4c804d79f22c8d4979811b4366d42cc2d7aecbb2cdc629b9193f4812db783808500a809a0d2b5e42f308b14ddcf7fe220d920d1b78beb7a6b3c8673c35ec818558697680f3b2b123d63aa50d845a7e791de573450bf3b9579ce303f2c792f79b2d5c669b8016959dc2a24aa0487cbdfd5c600a2a5d924ebb0a2d3c60e6dc5f3c76a7ce8f4b8014e3e0704c9a07636322335a3c663ec9fd9df8b7bf71d6e8183fefecfbfe0e5080c6f1b3ef9e5d7611f1f361ff2062d84a7d335e77d3c880f02d24feea5bdf9b9f80d26cf89b5888c69e5f4f4d3794ae08d3d00e68d9affcb2729bfc966d270a9e98804e521fec979042f9f76536ab4235fd1b8d1afd2c18d47adc7b3dca1eaa51d26b80906390c4c8b11eb5cffdecd9ccf06682331cf5d26cde0027957d01e2c8ab796280589808ce1244fbca0ed4fab70a26be5cc10196f45e67fbeea03de8ce1db7252c807bd3b61998a40099ccf7f4460ae58aa87c6f9820f36a2815b8262342e598388a80f395b7003a2eb1e39c624b9a707a6cb58c3cb6997932fc80662ae19c785a91f580b5e5172489541dfc581e116554b63de15fddf38ffed2b109394749c20b8f6ce380507d21c8bdca2e8caade7ca048118f10701503ce3148d4571162164d8f03dfcf
// 4: Bytes: Bytes
// 0x9e75edf06348b4330d1e88564111cb3d3000505f0e7b9012096b41c4eb3aaf947f6ea42908000080e29a40f02cfa5269c1332753ab2b5cffeee3290470283df858190200aaf9f5b9
// 5: Bytes: Bytes
// 0x9f0bf19e4ed2927982e234d989e812f3f3cb00808580d03fa7e35e370766c2b3d9df19f684ccf4715a0d113cd7f9c3d99a59d768804d59a150eff7c269d5d47475f10481fb566d8a58d6b354b45c4c177c60959a6580a86e83d48c884747d4fce67fc6e52390a82e82b29a16732d6d98933d0e818f9980bc920d0246a337d9606288d6f3121e6eed1b90858839fef39196ca60fc6d74d380ed89f06854e99da17903fe941db57b84e2ca8ada2daaef740380c8546f991334
// dipProof: KiltDipPrimitivesMerkleV0DidMerkleProof
// blinded: KiltDipPrimitivesUtilsBoundedBlindedValue
// 0: Bytes: Bytes
// 0x80f96e0000000000000000000000
// 1: Bytes: Bytes
// 0x8101059a000000000000
// 2: Bytes: Bytes
// 0x7f000f3265bdfa3d8550f0c9ec7e55a2fb9c491de6dd680a0746fe853e71295d964c00
// 3: Bytes: Bytes
// 0x7f000f1c72440ee93b212828350ec0c141578c0f715593cd5e82945644c7d4c101fa00
// 4: Bytes: Bytes
// 0x8002200000
// 5: Bytes: Bytes
// 0x7e2e02b0aa1541030250688cd5ec2680b6a16793ec3a782fba0b30aaf2ef34e300
// 6: Bytes: Bytes
// 0x7e7bc57994d2b763ce0a61ba0440b781924ea4b7258126ae1bfa708323b2c21800
// 7: Bytes: Bytes
// 0x7f000e7d79ed822a998f84770f4a5c30560ce10961a3858b03b299a6a0490b0dbe2c00
// 8: Bytes: Bytes
// 0x804003000000
// 9: Bytes: Bytes
// 0x7e582ccffa42f3a699a15efba7d5d97c20f08af9e88b7a0a364a3bf1da29dafd00
// 10: Bytes: Bytes
// 0x7e9281488f2ef8cf9d16634e5ea49bcef13759f779041c81bede37ffb63ee91700
// 11: Bytes: Bytes
// 0x7e989e67793c806841b7d2956119f64647c81b7d513844f65636b71caefdd5dd00
// 12: Bytes: Bytes
// 0x8010400000
// 13: Bytes: Bytes
// 0x7ec37bb4c8218d2c8344e0c6c2d194d2c05e4291b32f03fde8fc0274de73edf900
// 14: Bytes: Bytes
// 0x7e117b0e56e932598232017bb890354df5312d47449b088619308e042b57b5a800
// 15: Bytes: Bytes
// 0x8000880000
// 16: Bytes: Bytes
// 0x7f01310fde8496384b8c20bc818f0c6955a37f83e605d3ea5488ad6a374a33efa40000
// 17: Bytes: Bytes
// 0x7f01874a2420daa4afb54594763efdcb55f8f6a1a101fd7b147f2bad1ea7a2f9400000
// 18: Bytes: Bytes
// 0x8004080000
// 19: Bytes: Bytes
// 0x7f0126565087069c8569a8f4b38d7e1546952033fad36851e77d8bec414af8d4d10000
// 20: Bytes: Bytes
// 0x7f0132b04226023e7e95eb30dbc5ee6c306aee3d2a2b702fc7caa8081c081297430000
// 21: Bytes: Bytes
// 0x6f0c666438656532643466623632663336383539613338636300
// 22: Bytes: Bytes
// 0x7f020ac0e673e7aa207d1675c0658a0736a794413d91c43159c78e5d219bfd9c073b0000
// 23: Bytes: Bytes
// 0x7f040db8944f1f44b7df774613f6a7f9cb952fce5ec9657c979372123b8dfa623016010100
// 24: Bytes: Bytes
// 0x7f0207e584b851abd27e0c3415f8f7013e9b8a1943d286efdbada523ac830446c0470000
// 25: Bytes: Bytes
// 0x7f020022e4d270534ea7afb8ba032b8ecc2195c5f7efb248fc543526a3d89e8a26f20000
// 26: Bytes: Bytes
// 0x7f020e9c10b53da17f1f01330b8677a694194f3bae0fdc6b4bf37783e48565dc6c9d0000
// 27: Bytes: Bytes
// 0x8000810000
// 28: Bytes: Bytes
// 0x7f0122f4f36cedf467ce339d41834ce15025a9a333cf36cb7dc40e7b0126da7c200000
// 29: Bytes: Bytes
// 0x7f0171bc4251a285cd6daba2a81e510efb3e2807d58fc559e43a8d203f1f68e8a90000
// 30: Bytes: Bytes
// 0x8020020000
// 31: Bytes: Bytes
// 0x7f03022a79911de75700074d85abcb681e980a6913d75945d6006ba587f00adffc010300
// 32: Bytes: Bytes
// 0x7f033d86c388a7e9f8ac2f7e43ad5f9bbd0e8861bfefa24f8ac12350d1e44246b0010000
// revealed: Vec<KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf>
// 0: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xe93d86c388a7e9f8ac2f7e43ad5f9bbd0e8861bfefa24f8ac12350d1e44246b0

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Verification
// Verification: DidDidDetailsDidVerificationKeyRelationship
// Authentication
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicVerificationKey
// PublicVerificationKey: DidDidDetailsDidVerificationKey
// Sr25519
// Sr25519: SpCoreSr25519Public
// 0x0683f23efae459a54bf7c150bbd5e42b7556cfa979119831e68a751906270348
// blockNumber: u64
// 379
// 1: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x3b310fde8496384b8c20bc818f0c6955a37f83e605d3ea5488ad6a374a33efa4

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x96bfd654f691c75c0baa981d4a074e6ef65e13925f1a2fc397978d355e26b426
// blockNumber: u64
// 379
// 2: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x3f874a2420daa4afb54594763efdcb55f8f6a1a101fd7b147f2bad1ea7a2f940

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x05612dba4740d5cc3d4e16216cb9514a161fd7c6f3ff9e58e3bb86c413339f21
// blockNumber: u64
// 379
// 3: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x4226565087069c8569a8f4b38d7e1546952033fad36851e77d8bec414af8d4d1

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0xf69e393ffe95e1e61df8a768ee37f95816315034bd7eb97a40a1bfc532c89257
// blockNumber: u64
// 379
// 4: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x4b32b04226023e7e95eb30dbc5ee6c306aee3d2a2b702fc7caa8081c08129743

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x72c8838a8fc3f4b6da134252cd118e42f11f0c5b8d016f1dac516e2c1906542a
// blockNumber: u64
// 379
// 5: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x6ac0e673e7aa207d1675c0658a0736a794413d91c43159c78e5d219bfd9c073b

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x6c859e221aca424d4056269812111939be692bc69c5689b1f15bce9c86856012
// blockNumber: u64
// 379
// 6: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x97e584b851abd27e0c3415f8f7013e9b8a1943d286efdbada523ac830446c047

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0xf7f3bdf89cff9a64d5b39666ce1a949b19a264a4ce8baa9eb98cdaf3c0f4b94f
// blockNumber: u64
// 379
// 7: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xa022e4d270534ea7afb8ba032b8ecc2195c5f7efb248fc543526a3d89e8a26f2

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x2145538415fa47a36049968afcfe3393cffbd49e149ec9a1bc233782e41ae32f
// blockNumber: u64
// 379
// 8: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xbe9c10b53da17f1f01330b8677a694194f3bae0fdc6b4bf37783e48565dc6c9d

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x235350883f974dbe0cb70348396bf28fafa9fb3db9e5cbb9ca5c7d5a0a5dc73c
// blockNumber: u64
// 379
// 9: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xd822f4f36cedf467ce339d41834ce15025a9a333cf36cb7dc40e7b0126da7c20

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0x4e2a9ffe692030125764482be84637095bf1450b18106e05ae96ac81d971671d
// blockNumber: u64
// 379
// 10: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xdf71bc4251a285cd6daba2a81e510efb3e2807d58fc559e43a8d203f1f68e8a9

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Encryption
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicEncryptionKey
// PublicEncryptionKey: DidDidDetailsDidEncryptionKey
// X25519
// X25519: [u8;32]
// 0xff8268a136376b28176eb3360907e93780d38a51b448dc3f7bfdd013ed3db16a
// blockNumber: u64
// 379
// 11: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0x7db8944f1f44b7df774613f6a7f9cb952fce5ec9657c979372123b8dfa623016

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Verification
// Verification: DidDidDetailsDidVerificationKeyRelationship
// CapabilityDelegation
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicVerificationKey
// PublicVerificationKey: DidDidDetailsDidVerificationKey
// Ed25519
// Ed25519: SpCoreEd25519Public
// 0xdeb0ccb4c95616ff423b3802265c1d5b3bd0eaa87d6579a2b17b23520abffdef
// blockNumber: u64
// 379
// 12: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf DidKey
// DidKey: KiltDipPrimitivesMerkleV0RevealedDidKey
// id: H256
// 0xe5022a79911de75700074d85abcb681e980a6913d75945d6006ba587f00adffc

// relationship: KiltDipPrimitivesMerkleV0DidKeyRelationship
// Verification
// Verification: DidDidDetailsDidVerificationKeyRelationship
// AssertionMethod
// details: DidDidDetailsDidPublicKeyDetails
// key: DidDidDetailsDidPublicKey
// PublicVerificationKey
// PublicVerificationKey: DidDidDetailsDidVerificationKey
// Ed25519
// Ed25519: SpCoreEd25519Public
// 0xd360967ebd1ca13287c6931d25e4840e2339cfb6bb9353b44b8f5bd3e7164a9e
// blockNumber: u64
// 379
// 13: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJsVLCyoarADAV1n3BgiczcBiUStHPFzvydaLmotCvGxjSrN9
// gJsVLCyoarADAV1n3BgiczcBiUStHPFzvydaLmotCvGxjSrN9
// 14: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJrJXpA644Vf7unsFWYhVQyBzQvgvY9985wZA8LBgx23grzg4
// gJrJXpA644Vf7unsFWYhVQyBzQvgvY9985wZA8LBgx23grzg4
// 15: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJq2ZToxb9rVpqVGQG7Qjm5hxsvnPzc58pNydwWNGDQawZaB1
// gJq2ZToxb9rVpqVGQG7Qjm5hxsvnPzc58pNydwWNGDQawZaB1
// 16: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJsH8c7sxG19Lrbk4Uc2zXdFkinQLGs96WbVnqLCcaq7pkbHf
// gJsH8c7sxG19Lrbk4Uc2zXdFkinQLGs96WbVnqLCcaq7pkbHf
// 17: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJn68YLwkDNyY6KdzaTDkhF53eR4EriAXSw5Xqbi9czEKoPp7
// gJn68YLwkDNyY6KdzaTDkhF53eR4EriAXSw5Xqbi9czEKoPp7
// 18: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJqJh8viUjjWZhZVvZZXh7WWXQaDMCgNnmJiq5uHAh7Nvonzr
// gJqJh8viUjjWZhZVvZZXh7WWXQaDMCgNnmJiq5uHAh7Nvonzr
// 19: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJrEGXV9dydvYjXyBGGDGwkH7mAZmCWWZsrbe8pmDLGAQZaG5
// gJrEGXV9dydvYjXyBGGDGwkH7mAZmCWWZsrbe8pmDLGAQZaG5
// 20: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJnoyZ1ZExp5m7poy5TasNzn2hjDpHv3YrJmT83uPqs8VGkBZ
// gJnoyZ1ZExp5m7poy5TasNzn2hjDpHv3YrJmT83uPqs8VGkBZ
// 21: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJr3yDxDpNudsmE1ac4yfMTgU3uSEtDkLnz2zVjeMuRxDhWZV
// gJr3yDxDpNudsmE1ac4yfMTgU3uSEtDkLnz2zVjeMuRxDhWZV
// 22: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf LinkedAccount
// LinkedAccount: KiltDipPrimitivesMerkleV0RevealedAccountId
// AccountId32
// AccountId32: AccountId32
// gJrHBx3RnWDwy8ohRupg6257frM8RdjVxKynb3Ybu3C4WYhAp
// gJrHBx3RnWDwy8ohRupg6257frM8RdjVxKynb3Ybu3C4WYhAp
// 23: KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf:
// KiltDipPrimitivesMerkleV0RevealedDidMerkleProofLeaf Web3Name
// Web3Name: KiltDipPrimitivesMerkleV0RevealedWeb3Name
// web3Name: Bytes
// fd8ee2d4fb62f36859a38cc
// claimedAt: u64
// 379
// signature: KiltDipPrimitivesMerkleV0TimeBoundDidSignature
// signature: DidDidDetailsDidSignature
// Sr25519
// Sr25519: SpCoreSr25519Signature
// 0x2e21dd5d0d3908a8f928149c37b28292ee3b01ac97f8a965578527c2ce2a9317f613499561757090add2ebbbbca3eceead96098662fec650cfb342d815d4d88d
// validUntil: u64
// 308
// call: Call
// system.remark
// remark: Bytes
// Hello, world!

/// The state proof for a parachain head.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct ProviderHeadStateProof<RelayBlockNumber> {
	pub(crate) relay_block_number: RelayBlockNumber,
	pub(crate) proof: BoundedBlindedValue<u8>,
}

#[cfg(feature = "runtime-benchmarks")]
impl<RelayBlockNumber, Context> kilt_support::traits::GetWorstCase<Context> for ProviderHeadStateProof<RelayBlockNumber>
where
	RelayBlockNumber: Default,
{
	fn worst_case(context: Context) -> Self {
		Self {
			relay_block_number: RelayBlockNumber::default(),
			proof: BoundedBlindedValue::worst_case(context),
		}
	}
}

/// The state proof for a DIP commitment.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct DipCommitmentStateProof(pub(crate) BoundedBlindedValue<u8>);

#[cfg(feature = "runtime-benchmarks")]
impl<Context> kilt_support::traits::GetWorstCase<Context> for DipCommitmentStateProof {
	fn worst_case(context: Context) -> Self {
		Self(BoundedBlindedValue::worst_case(context))
	}
}

/// The Merkle proof for a KILT DID.
///
/// The generic types indicate the following:
/// * `ProviderDidKeyId`: The DID key ID type configured by the provider.
/// * `ProviderAccountId`: The `AccountId` type configured by the provider.
/// * `ProviderBlockNumber`: The `BlockNumber` type configured by the provider.
/// * `ProviderWeb3Name`: The web3name type configured by the provider.
/// * `ProviderLinkableAccountId`: The linkable account ID type configured by
///   the provider.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct DidMerkleProof<
	ProviderDidKeyId,
	ProviderAccountId,
	ProviderBlockNumber,
	ProviderWeb3Name,
	ProviderLinkableAccountId,
> {
	pub(crate) blinded: BoundedBlindedValue<u8>,
	pub(crate) revealed: Vec<
		RevealedDidMerkleProofLeaf<
			ProviderDidKeyId,
			ProviderAccountId,
			ProviderBlockNumber,
			ProviderWeb3Name,
			ProviderLinkableAccountId,
		>,
	>,
}

impl<ProviderDidKeyId, ProviderAccountId, ProviderBlockNumber, ProviderWeb3Name, ProviderLinkableAccountId>
	DidMerkleProof<ProviderDidKeyId, ProviderAccountId, ProviderBlockNumber, ProviderWeb3Name, ProviderLinkableAccountId>
{
	pub fn new(
		blinded: BoundedBlindedValue<u8>,
		revealed: Vec<
			RevealedDidMerkleProofLeaf<
				ProviderDidKeyId,
				ProviderAccountId,
				ProviderBlockNumber,
				ProviderWeb3Name,
				ProviderLinkableAccountId,
			>,
		>,
	) -> Self {
		Self { blinded, revealed }
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		ProviderDidKeyId,
		ProviderAccountId,
		ProviderBlockNumber,
		ProviderWeb3Name,
		ProviderLinkableAccountId,
		Context,
	> kilt_support::traits::GetWorstCase<Context>
	for DidMerkleProof<
		ProviderDidKeyId,
		ProviderAccountId,
		ProviderBlockNumber,
		ProviderWeb3Name,
		ProviderLinkableAccountId,
	> where
	ProviderDidKeyId: Default + Clone,
	ProviderAccountId: Clone,
	ProviderBlockNumber: Default + Clone,
	ProviderWeb3Name: Clone,
	ProviderLinkableAccountId: Clone,
{
	fn worst_case(context: Context) -> Self {
		Self {
			blinded: BoundedBlindedValue::worst_case(context),
			revealed: sp_std::vec![RevealedDidMerkleProofLeaf::default(); 64],
		}
	}
}

/// A DID signature anchored to a specific block height.
///
/// The generic types indicate the following:
/// * `BlockNumber`: The `BlockNumber` definition of the chain consuming (i.e.,
///   validating) this signature.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct TimeBoundDidSignature<BlockNumber> {
	/// The signature.
	pub(crate) signature: DidSignature,
	/// The block number until the signature is to be considered valid.
	pub(crate) valid_until: BlockNumber,
}

#[cfg(feature = "runtime-benchmarks")]
impl<BlockNumber, Context> kilt_support::traits::GetWorstCase<Context> for TimeBoundDidSignature<BlockNumber>
where
	DidSignature: kilt_support::traits::GetWorstCase<Context>,
	BlockNumber: Default,
{
	fn worst_case(context: Context) -> Self {
		Self {
			signature: DidSignature::worst_case(context),
			valid_until: BlockNumber::default(),
		}
	}
}

pub enum Error {
	InvalidRelayHeader,
	RelayBlockNotFound,
	RelayStateRootNotFound,
	InvalidDidMerkleProof,
	TooManyLeavesRevealed,
	InvalidSignatureTime,
	InvalidDidKeyRevealed,
	ParaHeadMerkleProof(MerkleProofError),
	DipCommitmentMerkleProof(MerkleProofError),
	Internal,
}

impl From<Error> for u8 {
	fn from(value: Error) -> Self {
		match value {
			Error::InvalidRelayHeader => 1,
			Error::RelayBlockNotFound => 2,
			Error::RelayStateRootNotFound => 3,
			Error::InvalidDidMerkleProof => 4,
			Error::TooManyLeavesRevealed => 5,
			Error::InvalidSignatureTime => 6,
			Error::InvalidDidKeyRevealed => 7,
			Error::ParaHeadMerkleProof(error) => match error {
				MerkleProofError::InvalidProof => 11,
				MerkleProofError::RequiredLeafNotRevealed => 12,
				MerkleProofError::ResultDecoding => 13,
				MerkleProofError::InputTooShort => 14,
			},
			Error::DipCommitmentMerkleProof(error) => match error {
				MerkleProofError::InvalidProof => 21,
				MerkleProofError::RequiredLeafNotRevealed => 22,
				MerkleProofError::ResultDecoding => 23,
				MerkleProofError::InputTooShort => 24,
			},
			Error::Internal => u8::MAX,
		}
	}
}

//TODO: steps:
// 1. Create a DID with a web3name and the maximum number of allowed linked
//    accounts
// 2. Create an identity commitment
// 3. Call the cross-chain operation, and take not of the generated proof.

/// A DIP proof submitted to a relaychain consumer.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `RelayHasher`: The hashing algorithm used by the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct RelayDipDidProof<
	RelayBlockNumber: Copy + Into<U256> + TryFrom<U256>,
	RelayHasher: Hash,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
> {
	/// The relaychain header for the relaychain block specified in the
	/// `provider_head_proof`.
	pub(crate) relay_header: Header<RelayBlockNumber, RelayHasher>,
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<RelayBlockNumber>,
}

impl<
		RelayBlockNumber: Member + sp_std::hash::Hash + Copy + MaybeDisplay + AtLeast32BitUnsigned + Codec + Into<U256> + TryFrom<U256>,
		RelayHasher: Hash,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
	RelayDipDidProof<
		RelayBlockNumber,
		RelayHasher,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
{
	/// Verifies the relaychain part of the state proof using the provided block
	/// hash.
	#[allow(clippy::type_complexity)]
	pub fn verify_relay_header_with_block_hash(
		self,
		block_hash: &OutputOf<RelayHasher>,
	) -> Result<
		DipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			RelayBlockNumber,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
		Error,
	> {
		if block_hash != &self.relay_header.hash() {
			return Err(Error::InvalidRelayHeader);
		}

		Ok(DipDidProofWithVerifiedRelayStateRoot {
			relay_state_root: self.relay_header.state_root,
			provider_head_proof: self.provider_head_proof,
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}

	/// Verifies the relaychain part of the state proof using the block hash
	/// returned by the provided implementation.
	///
	/// The generic types indicate the following:
	/// * `RelayHashStore`: The type that returns a relaychain block hash given
	///   a relaychain block number.
	#[allow(clippy::type_complexity)]
	pub fn verify_relay_header<RelayHashStore>(
		self,
	) -> Result<
		DipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			RelayBlockNumber,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
		Error,
	>
	where
		RelayHashStore: GetWithArg<RelayBlockNumber, Result = Option<OutputOf<RelayHasher>>>,
	{
		let relay_block_hash = RelayHashStore::get(&self.relay_header.number).ok_or(Error::RelayBlockNotFound)?;
		self.verify_relay_header_with_block_hash(&relay_block_hash)
	}
}

/// A DIP proof submitted to a relaychain consumer that has had the proof header
/// verified against a given block hash.
///
/// The generic types indicate the following:
/// * `StateRoot`: The type of the state root used by the relaychain.
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
pub struct DipDidProofWithVerifiedRelayStateRoot<
	StateRoot,
	RelayBlockNumber,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
> {
	/// The verified state root for the relaychain at the block specified in the
	/// proof.
	pub(crate) relay_state_root: StateRoot,
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<RelayBlockNumber>,
}

impl<
		StateRoot,
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
	DipDidProofWithVerifiedRelayStateRoot<
		StateRoot,
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	> where
	KiltBlockNumber: BenchmarkDefault,
{
	/// Verifies the head data of the state proof for the provider with the
	/// given para ID.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The head data hashing algorithm used by the relaychain.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof<RelayHasher, ProviderHeader>(
		self,
		provider_para_id: u32,
	) -> Result<
		DipDidProofWithoutRelayProof<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			RelayBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash<Output = StateRoot>,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let parachain_dip_proof = ParachainDipDidProof {
			provider_head_proof: self.provider_head_proof,
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		};

		parachain_dip_proof.verify_provider_head_proof_with_state_root::<RelayHasher, ProviderHeader>(
			provider_para_id,
			&self.relay_state_root,
		)
	}
}

/// A DIP proof submitted to a parachain consumer.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct ParachainDipDidProof<
	RelayBlockNumber,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		Context,
	> kilt_support::traits::GetWorstCase<Context>
	for ParachainDipDidProof<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	RelayBlockNumber: Default,
	KiltDidKeyId: Default + Clone,
	KiltAccountId: Clone,
	KiltBlockNumber: Default + Clone,
	KiltWeb3Name: Clone,
	KiltLinkableAccountId: Clone,
	ConsumerBlockNumber: Default,
	Context: Clone,
{
	fn worst_case(context: Context) -> Self {
		Self {
			provider_head_proof: ProviderHeadStateProof::worst_case(context.clone()),
			dip_commitment_proof: DipCommitmentStateProof::worst_case(context.clone()),
			dip_proof: DidMerkleProof::worst_case(context.clone()),
			signature: TimeBoundDidSignature::worst_case(context),
		}
	}
}

impl<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	ParachainDipDidProof<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	KiltBlockNumber: BenchmarkDefault,
{
	/// Verifies the head data of the state proof for the provider with the
	/// given para ID and relaychain state root.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The head data hashing algorithm used by the relaychain.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof_with_state_root<RelayHasher, ProviderHeader>(
		self,
		provider_para_id: u32,
		relay_state_root: &OutputOf<RelayHasher>,
	) -> Result<
		DipDidProofWithoutRelayProof<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let provider_head_storage_key = calculate_parachain_head_storage_key(provider_para_id);
		// TODO: Figure out why RPC call returns 2 bytes in front which we don't need
		let provider_header_result = verify_storage_value_proof_by_trimming_result::<_, RelayHasher, ProviderHeader>(
			&provider_head_storage_key,
			*relay_state_root,
			self.provider_head_proof.proof,
			2,
		);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let provider_header = provider_header_result.unwrap_or_else(|_| ProviderHeader::new(<ProviderHeader as HeaderT>::Number::default(), <ProviderHeader as HeaderT>::Hash::default(), <ProviderHeader as HeaderT>::Hash::default(), <ProviderHeader as HeaderT>::Hash::default(), sp_runtime::Digest::default()));
			} else {
				let provider_header = provider_header_result.map_err(Error::ParaHeadMerkleProof)?;
				log::trace!(target: "dip-consumer::ParachainDipDidProof::verify_provider_head_proof_with_state_root", "Parachain header verified: {:#?}", provider_header);
			}
		}
		Ok(DipDidProofWithoutRelayProof {
			state_root: *provider_header.state_root(),
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}

	/// Verifies the head data of the state proof for the provider with the
	/// given para ID using the state root returned by the provided
	/// implementation.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The hashing algorithm used on the relaychain to
	///   generate the parachains head data.
	/// * `StateRootStore`: The type that returns a relaychain state root given
	///   a relaychain block number.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof<RelayHasher, StateRootStore, ProviderHeader>(
		self,
		provider_para_id: u32,
	) -> Result<
		DipDidProofWithoutRelayProof<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash,
		StateRootStore: GetWithArg<RelayBlockNumber, Result = Option<OutputOf<RelayHasher>>>,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let relay_state_root = StateRootStore::get(&self.provider_head_proof.relay_block_number);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let relay_state_root = relay_state_root.unwrap_or_default();
			} else {
				let relay_state_root = relay_state_root.ok_or(Error::RelayStateRootNotFound)?;
				log::trace!(target: "dip-consumer::ParachainDipDidProof::verify_provider_head_proof", "Relay root retrieved for provided proof height: {:#04x?}", relay_state_root);
			}
		}
		self.verify_provider_head_proof_with_state_root::<RelayHasher, ProviderHeader>(
			provider_para_id,
			&relay_state_root,
		)
	}
}

/// A DIP proof that has had the proof header and the relaychain state verified
/// for the provided relaychain block number.
///
/// The generic types indicate the following:
/// * `StateRoot`: The type of the relaychain state root.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
pub struct DipDidProofWithoutRelayProof<
	StateRoot,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The relaychain state root for the block specified in the DIP proof.
	pub(crate) state_root: StateRoot,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		StateRoot,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	DipDidProofWithoutRelayProof<
		StateRoot,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
{
	/// Verifies the DIP commitment part of the state proof for the subject with
	/// the given identifier.
	///
	/// The generic types indicate the following:
	/// * `ParachainHasher`: The hashing algorithm used to hash storage on the
	///   parachain.
	/// * `ProviderRuntime`: The provider runtime definition.
	#[allow(clippy::type_complexity)]
	pub fn verify_dip_commitment_proof_for_subject<ParachainHasher, ProviderRuntime>(
		self,
		subject: &ProviderRuntime::Identifier,
	) -> Result<
		DipDidProofWithVerifiedCommitment<
			IdentityCommitmentOf<ProviderRuntime>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		StateRoot: Ord,
		ParachainHasher: Hash<Output = StateRoot>,
		ProviderRuntime: pallet_dip_provider::Config,
		IdentityCommitmentOf<ProviderRuntime>: BenchmarkDefault,
	{
		let dip_commitment_storage_key =
			calculate_dip_identity_commitment_storage_key_for_runtime::<ProviderRuntime>(subject, 0);
		let dip_commitment_result =
			verify_storage_value_proof::<_, ParachainHasher, IdentityCommitmentOf<ProviderRuntime>>(
				&dip_commitment_storage_key,
				self.state_root,
				self.dip_commitment_proof.0,
			);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let dip_commitment = dip_commitment_result.unwrap_or_default();
			} else {
				let dip_commitment = dip_commitment_result.map_err(Error::DipCommitmentMerkleProof)?;
				log::trace!(target: "dip-consumer::DipDidProofWithoutRelayProof::verify_dip_commitment_proof_for_subject", "DIP commitment retrieved from provided proof: {:#?}", dip_commitment);
			}
		}
		Ok(DipDidProofWithVerifiedCommitment {
			dip_commitment,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}
}

/// A DIP proof that has had the relaychain state and the DIP commitment
/// verified for the provided relaychain block number.
///
/// The generic types indicate the following:
/// * `Commitment`: The DIP identity commitment type configured by the KILT
///   chain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
pub struct DipDidProofWithVerifiedCommitment<
	Commitment,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The verified DIP identity commitment.
	pub(crate) dip_commitment: Commitment,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	DipDidProofWithVerifiedCommitment<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	KiltDidKeyId: Encode,
	KiltAccountId: Encode,
	KiltBlockNumber: Encode,
	KiltWeb3Name: Encode,
	KiltLinkableAccountId: Encode,
{
	/// Verifies the Merkle proof of the subject's DID details.
	///
	/// The generic types indicate the following:
	/// * `DidMerkleHasher`: The hashing algorithm used to merkleize the DID
	///   details.
	/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable
	///   in the proof.
	pub fn verify_dip_proof<DidMerkleHasher, const MAX_REVEALED_LEAVES_COUNT: u32>(
		self,
	) -> Result<
		DipDetailsAndUnverifiedDidSignatureTime<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	>
	where
		KiltDidKeyId: sp_std::fmt::Debug,
		KiltAccountId: sp_std::fmt::Debug,
		KiltBlockNumber: sp_std::fmt::Debug,
		KiltWeb3Name: sp_std::fmt::Debug,
		KiltLinkableAccountId: sp_std::fmt::Debug,
		Commitment: sp_std::fmt::Debug,
		DidMerkleHasher: Hash<Output = Commitment>,
	{
		log::trace!(target: "dip-consumer::DipDidProofWithVerifiedCommitment::verify_dip_proof", "Blinded input proof: {:#?} - Revealed input proof: {:#?} - Commitment: {:#?}", self.dip_proof.blinded, self.dip_proof.revealed, self.dip_commitment);
		let mut revealed_leaves_iter = self.dip_proof.revealed.iter();
		// If more than `max_revealed_leaves_count` are revealed, return an error.
		ensure!(
			revealed_leaves_iter.by_ref().count() <= MAX_REVEALED_LEAVES_COUNT.saturated_into(),
			Error::TooManyLeavesRevealed
		);

		let proof_leaves_key_value_pairs: Vec<(Vec<u8>, Option<Vec<u8>>)> = revealed_leaves_iter
			.map(|revealed_leaf| (revealed_leaf.encoded_key(), Some(revealed_leaf.encoded_value())))
			.collect();
		let proof_verification_result = verify_trie_proof::<LayoutV1<DidMerkleHasher>, _, _, _>(
			&self.dip_commitment,
			&self.dip_proof.blinded[..],
			&proof_leaves_key_value_pairs[..],
		);

		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				drop(proof_verification_result);
			} else {
				proof_verification_result.map_err(|_| Error::InvalidDidMerkleProof)?;
			}
		}
		let revealed_leaves = BoundedVec::try_from(self.dip_proof.revealed).map_err(|_| {
			log::error!("Should not fail to construct BoundedVec since bounds were checked before.");
			Error::Internal
		})?;

		Ok(DipDetailsAndUnverifiedDidSignatureTime {
			revealed_leaves,
			signature: self.signature,
		})
	}
}

/// A DIP proof whose information has been verified but that contains a
/// cross-chain [`TimeBoundDidSignature`] that still needs verification.
///
/// The generic types indicate the following:
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable in
///   the proof.
pub struct DipDetailsAndUnverifiedDidSignatureTime<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	pub(crate) revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipDetailsAndUnverifiedDidSignatureTime<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	ConsumerBlockNumber: PartialOrd,
{
	/// Verifies that the DIP proof signature is anchored to a block that has
	/// not passed on the consumer chain.
	pub fn verify_signature_time(
		self,
		block_number: &ConsumerBlockNumber,
	) -> Result<
		DipDetailsAndUnverifiedDidSignaturePayload<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	> {
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let _ = self.signature.valid_until >= *block_number;
			} else {
				frame_support::ensure!(self.signature.valid_until >= *block_number, Error::InvalidSignatureTime);
			}
		}
		Ok(DipDetailsAndUnverifiedDidSignaturePayload {
			revealed_leaves: self.revealed_leaves,
			signature: self.signature.signature,
		})
	}
}

/// A DIP proof whose information has been verified and whose signature has been
/// verified not to be expired, but that yet does not contain information as to
/// which of the revealed keys has generated the signature.
///
/// The generic types indicate the following:
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable in
///   the proof.
pub struct DipDetailsAndUnverifiedDidSignaturePayload<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	pub(crate) revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The cross-chain DID signature without time information.
	pub(crate) signature: DidSignature,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipDetailsAndUnverifiedDidSignaturePayload<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	KiltDidKeyId: BenchmarkDefault,
	KiltBlockNumber: BenchmarkDefault,
{
	/// Iterates over the revealed DID leafs to find the one that generated a
	/// valid signature for the provided payload.
	pub fn retrieve_signing_leaf_for_payload(
		self,
		payload: &[u8],
	) -> Result<
		DipVerifiedInfo<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	> {
		let revealed_verification_keys = self.revealed_leaves.iter().filter(|leaf| {
			matches!(
				leaf,
				RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey {
					relationship: DidKeyRelationship::Verification(_),
					..
				})
			)
		});
		let maybe_signing_key_index = revealed_verification_keys
			.enumerate()
			.find(|(_, revealed_verification_key)| {
				let RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey {
					details:
						DidPublicKeyDetails {
							key: DidPublicKey::PublicVerificationKey(verification_key),
							..
						},
					..
				}) = revealed_verification_key
				else {
					return false;
				};
				verification_key.verify_signature(payload, &self.signature).is_ok()
			})
			.map(|(index, _)| u32::saturated_from(index));

		let signing_key_entry = if let Some(index) = maybe_signing_key_index {
			(self.revealed_leaves, index)
		} else {
			cfg_if::cfg_if! {
				if #[cfg(feature = "runtime-benchmarks")] {
						return Ok(DipVerifiedInfo::default());
				} else {
					return Err(Error::InvalidDidKeyRevealed);
				}
			}
		};

		Ok(DipVerifiedInfo {
			revealed_leaves: signing_key_entry.0,
			signing_leaf_index: signing_key_entry.1,
		})
	}
}

/// Information, available as an origin, after the whole DIP proof has been
/// verified.
#[derive(Clone, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct DipVerifiedInfo<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The index of the signing leaf from the vector above,
	signing_leaf_index: u32,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipVerifiedInfo<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	>
{
	/// Returns an iterator over the revealed DID leaves.
	pub fn iter_leaves(
		&self,
	) -> impl Iterator<
		Item = &RevealedDidMerkleProofLeaf<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
	> {
		self.revealed_leaves.iter()
	}

	/// Returns a reference to the leaf that signed the cross-chain operation.
	/// This operation should never fail, so the only error it returns is an
	/// `Error::Internal` which, anyway, should never happen.
	pub fn get_signing_leaf(&self) -> Result<&RevealedDidKey<KiltDidKeyId, KiltBlockNumber, KiltAccountId>, Error> {
		let leaf = &self
			.revealed_leaves
			.get(usize::saturated_from(self.signing_leaf_index))
			.ok_or_else(|| {
				log::error!("Should never fail to retrieve the signing leaf.");
				Error::Internal
			})?;
		let RevealedDidMerkleProofLeaf::DidKey(did_key) = leaf else {
			log::error!("Should never fail to convert the signing leaf to a DID Key leaf.");
			return Err(Error::Internal);
		};
		Ok(did_key)
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	> Default
	for DipVerifiedInfo<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	KiltDidKeyId: BenchmarkDefault,
	KiltBlockNumber: BenchmarkDefault,
{
	fn default() -> Self {
		let default_keys = sp_std::vec![RevealedDidKey {
			id: KiltDidKeyId::default(),
			details: DidPublicKeyDetails {
				key: did::did_details::DidVerificationKey::Ed25519(sp_core::ed25519::Public::from_raw([0u8; 32]))
					.into(),
				block_number: KiltBlockNumber::default()
			},
			relationship: DidVerificationKeyRelationship::Authentication.into()
		}
		.into()];
		let bounded_keys = default_keys
			.try_into()
			// To avoid requiring types to implement `Debug`.
			.map_err(|_| "Should not fail to convert single element to a BoundedVec.")
			.unwrap();
		Self {
			revealed_leaves: bounded_keys,
			signing_leaf_index: 0u32,
		}
	}
}

/// Relationship of a key to a DID Document.
#[derive(Clone, Copy, RuntimeDebug, Encode, Decode, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub enum DidKeyRelationship {
	Encryption,
	Verification(DidVerificationKeyRelationship),
}

impl From<DidVerificationKeyRelationship> for DidKeyRelationship {
	fn from(value: DidVerificationKeyRelationship) -> Self {
		Self::Verification(value)
	}
}

impl TryFrom<DidKeyRelationship> for DidVerificationKeyRelationship {
	type Error = ();

	fn try_from(value: DidKeyRelationship) -> Result<Self, Self::Error> {
		if let DidKeyRelationship::Verification(rel) = value {
			Ok(rel)
		} else {
			Err(())
		}
	}
}

/// All possible Merkle leaf types that can be revealed as part of a DIP
/// identity Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, Eq, RuntimeDebug, TypeInfo, MaxEncodedLen)]
pub enum RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> {
	DidKey(RevealedDidKey<KeyId, BlockNumber, AccountId>),
	Web3Name(RevealedWeb3Name<Web3Name, BlockNumber>),
	LinkedAccount(RevealedAccountId<LinkedAccountId>),
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedDidKey<KeyId, BlockNumber, AccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedDidKey<KeyId, BlockNumber, AccountId>) -> Self {
		Self::DidKey(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedWeb3Name<Web3Name, BlockNumber>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedWeb3Name<Web3Name, BlockNumber>) -> Self {
		Self::Web3Name(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedAccountId<LinkedAccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedAccountId<LinkedAccountId>) -> Self {
		Self::LinkedAccount(value)
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> Default
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Default,
	BlockNumber: Default,
{
	fn default() -> Self {
		RevealedDidKey {
			id: KeyId::default(),
			relationship: DidVerificationKeyRelationship::Authentication.into(),
			details: DidPublicKeyDetails {
				key: did::did_details::DidVerificationKey::Ed25519(sp_core::ed25519::Public::from_raw([0u8; 32]))
					.into(),
				block_number: BlockNumber::default(),
			},
		}
		.into()
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Encode,
	Web3Name: Encode,
	LinkedAccountId: Encode,
{
	pub fn encoded_key(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { id, relationship, .. }) => (id, relationship).encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { web3_name, .. }) => web3_name.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(RevealedAccountId(account_id)) => account_id.encode(),
		}
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	AccountId: Encode,
	BlockNumber: Encode,
{
	pub fn encoded_value(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { details, .. }) => details.encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { claimed_at, .. }) => claimed_at.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(_) => ().encode(),
		}
	}
}

/// The details of a DID key after it has been successfully verified in a Merkle
/// proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, RuntimeDebug, TypeInfo)]
pub struct RevealedDidKey<KeyId, BlockNumber, AccountId> {
	/// The key ID, according to the provider's definition.
	pub id: KeyId,
	/// The key relationship to the subject's DID Document.
	pub relationship: DidKeyRelationship,
	/// The details of the DID Key, including its creation block number on the
	/// provider chain.
	pub details: DidPublicKeyDetails<BlockNumber, AccountId>,
}

/// The details of a web3name after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, RuntimeDebug, TypeInfo)]
pub struct RevealedWeb3Name<Web3Name, BlockNumber> {
	/// The web3name.
	pub web3_name: Web3Name,
	/// The block number on the provider chain in which it was linked to the DID
	/// subject.
	pub claimed_at: BlockNumber,
}

/// The details of an account after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Encode, Decode, PartialEq, MaxEncodedLen, Eq, RuntimeDebug, TypeInfo)]
pub struct RevealedAccountId<AccountId>(pub AccountId);
