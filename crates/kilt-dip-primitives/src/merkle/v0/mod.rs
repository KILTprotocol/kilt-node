// KILT Blockchain â€“ https://botlabs.org
// Copyright (C) 2019-2023 BOTLabs GmbH

// The KILT Blockchain is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The KILT Blockchain is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// If you feel like getting in touch with us, you can do so at info@botlabs.org

//! Module to deal with cross-chain Merkle proof as generated by the KILT chain.

use did::{
	did_details::{DidPublicKey, DidPublicKeyDetails},
	DidSignature, DidVerificationKeyRelationship,
};
use frame_support::ensure;
use pallet_dip_provider::IdentityCommitmentOf;
use parity_scale_codec::{Codec, Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;
use sp_core::{ConstU32, U256};
use sp_runtime::{
	generic::Header,
	traits::{AtLeast32BitUnsigned, Hash, Header as HeaderT, MaybeDisplay, Member},
	BoundedVec, SaturatedConversion,
};
use sp_std::{fmt::Debug, vec::Vec};
use sp_trie::{verify_trie_proof, LayoutV1};

use crate::{
	state_proofs::{verify_storage_value_proof, verify_storage_value_proof_with_decoder},
	traits::{BenchmarkDefault, GetWithArg},
	utils::{
		calculate_dip_identity_commitment_storage_key_for_runtime, calculate_parachain_head_storage_key,
		BoundedBlindedValue, OutputOf,
	},
};

mod error;
pub use error::*;

/// The state proof for a parachain head.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct ProviderHeadStateProof<RelayBlockNumber> {
	pub(crate) relay_block_number: RelayBlockNumber,
	pub(crate) proof: BoundedBlindedValue<u8>,
}

#[cfg(feature = "runtime-benchmarks")]
impl<RelayBlockNumber, Context> kilt_support::traits::GetWorstCase<Context> for ProviderHeadStateProof<RelayBlockNumber>
where
	RelayBlockNumber: Default,
{
	fn worst_case(context: Context) -> Self {
		Self {
			relay_block_number: RelayBlockNumber::default(),
			proof: BoundedBlindedValue::worst_case(context),
		}
	}
}

/// The state proof for a DIP commitment.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct DipCommitmentStateProof(pub(crate) BoundedBlindedValue<u8>);

#[cfg(feature = "runtime-benchmarks")]
impl<Context> kilt_support::traits::GetWorstCase<Context> for DipCommitmentStateProof {
	fn worst_case(context: Context) -> Self {
		Self(BoundedBlindedValue::worst_case(context))
	}
}

/// The Merkle proof for a KILT DID.
///
/// The generic types indicate the following:
/// * `ProviderDidKeyId`: The DID key ID type configured by the provider.
/// * `ProviderAccountId`: The `AccountId` type configured by the provider.
/// * `ProviderBlockNumber`: The `BlockNumber` type configured by the provider.
/// * `ProviderWeb3Name`: The web3name type configured by the provider.
/// * `ProviderLinkableAccountId`: The linkable account ID type configured by
///   the provider.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct DidMerkleProof<
	ProviderDidKeyId,
	ProviderAccountId,
	ProviderBlockNumber,
	ProviderWeb3Name,
	ProviderLinkableAccountId,
> {
	pub(crate) blinded: BoundedBlindedValue<u8>,
	pub(crate) revealed: Vec<
		RevealedDidMerkleProofLeaf<
			ProviderDidKeyId,
			ProviderAccountId,
			ProviderBlockNumber,
			ProviderWeb3Name,
			ProviderLinkableAccountId,
		>,
	>,
}

impl<ProviderDidKeyId, ProviderAccountId, ProviderBlockNumber, ProviderWeb3Name, ProviderLinkableAccountId>
	DidMerkleProof<ProviderDidKeyId, ProviderAccountId, ProviderBlockNumber, ProviderWeb3Name, ProviderLinkableAccountId>
{
	pub fn new(
		blinded: BoundedBlindedValue<u8>,
		revealed: Vec<
			RevealedDidMerkleProofLeaf<
				ProviderDidKeyId,
				ProviderAccountId,
				ProviderBlockNumber,
				ProviderWeb3Name,
				ProviderLinkableAccountId,
			>,
		>,
	) -> Self {
		Self { blinded, revealed }
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		ProviderDidKeyId,
		ProviderAccountId,
		ProviderBlockNumber,
		ProviderWeb3Name,
		ProviderLinkableAccountId,
		Context,
	> kilt_support::traits::GetWorstCase<Context>
	for DidMerkleProof<
		ProviderDidKeyId,
		ProviderAccountId,
		ProviderBlockNumber,
		ProviderWeb3Name,
		ProviderLinkableAccountId,
	> where
	ProviderDidKeyId: Default + Clone,
	ProviderAccountId: Clone,
	ProviderBlockNumber: Default + Clone,
	ProviderWeb3Name: Clone,
	ProviderLinkableAccountId: Clone,
{
	fn worst_case(context: Context) -> Self {
		Self {
			blinded: BoundedBlindedValue::worst_case(context),
			revealed: sp_std::vec![RevealedDidMerkleProofLeaf::default(); 64],
		}
	}
}

/// A DID signature anchored to a specific block height.
///
/// The generic types indicate the following:
/// * `BlockNumber`: The `BlockNumber` definition of the chain consuming (i.e.,
///   validating) this signature.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct TimeBoundDidSignature<BlockNumber> {
	/// The signature.
	pub(crate) signature: DidSignature,
	/// The block number until the signature is to be considered valid.
	pub(crate) valid_until: BlockNumber,
}

impl<BlockNumber> TimeBoundDidSignature<BlockNumber> {
	pub fn new(signature: DidSignature, valid_until: BlockNumber) -> Self {
		Self { signature, valid_until }
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<BlockNumber, Context> kilt_support::traits::GetWorstCase<Context> for TimeBoundDidSignature<BlockNumber>
where
	DidSignature: kilt_support::traits::GetWorstCase<Context>,
	BlockNumber: Default,
{
	fn worst_case(context: Context) -> Self {
		Self {
			signature: DidSignature::worst_case(context),
			valid_until: BlockNumber::default(),
		}
	}
}

/// A DIP proof submitted to a relaychain consumer.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `RelayHasher`: The hashing algorithm used by the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct RelayDipDidProof<
	RelayBlockNumber: Copy + Into<U256> + TryFrom<U256>,
	RelayHasher: Hash,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
> {
	/// The relaychain header for the relaychain block specified in the
	/// `provider_head_proof`.
	pub(crate) relay_header: Header<RelayBlockNumber, RelayHasher>,
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<RelayBlockNumber>,
}

impl<
		RelayBlockNumber: Member + sp_std::hash::Hash + Copy + MaybeDisplay + AtLeast32BitUnsigned + Codec + Into<U256> + TryFrom<U256>,
		RelayHasher: Hash,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
	RelayDipDidProof<
		RelayBlockNumber,
		RelayHasher,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
{
	/// Verifies the relaychain part of the state proof using the provided block
	/// hash.
	#[allow(clippy::type_complexity)]
	pub fn verify_relay_header_with_block_hash(
		self,
		block_hash: &OutputOf<RelayHasher>,
	) -> Result<
		RelayDipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			RelayBlockNumber,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
		Error,
	> {
		if block_hash != &self.relay_header.hash() {
			return Err(Error::InvalidRelayHeader);
		}

		Ok(RelayDipDidProofWithVerifiedRelayStateRoot {
			relay_state_root: self.relay_header.state_root,
			provider_head_proof: self.provider_head_proof,
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}

	/// Verifies the relaychain part of the state proof using the block hash
	/// returned by the provided implementation.
	///
	/// The generic types indicate the following:
	/// * `RelayHashStore`: The type that returns a relaychain block hash given
	///   a relaychain block number.
	#[allow(clippy::type_complexity)]
	pub fn verify_relay_header<RelayHashStore>(
		self,
	) -> Result<
		RelayDipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			RelayBlockNumber,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
		Error,
	>
	where
		RelayHashStore: GetWithArg<RelayBlockNumber, Result = Option<OutputOf<RelayHasher>>>,
	{
		let relay_block_hash = RelayHashStore::get(&self.relay_header.number).ok_or(Error::RelayBlockNotFound)?;
		self.verify_relay_header_with_block_hash(&relay_block_hash)
	}
}

/// A DIP proof submitted to a relaychain consumer that has had the proof header
/// verified against a given block hash.
///
/// The generic types indicate the following:
/// * `StateRoot`: The type of the state root used by the relaychain.
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
#[derive(Debug)]
pub struct RelayDipDidProofWithVerifiedRelayStateRoot<
	StateRoot,
	RelayBlockNumber,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
> {
	/// The verified state root for the relaychain at the block specified in the
	/// proof.
	pub(crate) relay_state_root: StateRoot,
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<RelayBlockNumber>,
}

impl<
		StateRoot,
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	>
	RelayDipDidProofWithVerifiedRelayStateRoot<
		StateRoot,
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
	> where
	KiltBlockNumber: BenchmarkDefault,
{
	/// Verifies the head data of the state proof for the provider with the
	/// given para ID.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The head data hashing algorithm used by the relaychain.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof<RelayHasher, ProviderHeader>(
		self,
		provider_para_id: u32,
	) -> Result<
		DipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			RelayBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash<Output = StateRoot>,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let parachain_dip_proof = ParachainDipDidProof {
			provider_head_proof: self.provider_head_proof,
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		};

		parachain_dip_proof.verify_provider_head_proof_with_state_root::<RelayHasher, ProviderHeader>(
			provider_para_id,
			&self.relay_state_root,
		)
	}
}

/// A DIP proof submitted to a parachain consumer.
///
/// The generic types indicate the following:
/// * `RelayBlockNumber`: The `BlockNumber` definition of the relaychain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo)]
pub struct ParachainDipDidProof<
	RelayBlockNumber,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The state proof for the given parachain head.
	pub(crate) provider_head_proof: ProviderHeadStateProof<RelayBlockNumber>,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		Context,
	> kilt_support::traits::GetWorstCase<Context>
	for ParachainDipDidProof<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	RelayBlockNumber: Default,
	KiltDidKeyId: Default + Clone,
	KiltAccountId: Clone,
	KiltBlockNumber: Default + Clone,
	KiltWeb3Name: Clone,
	KiltLinkableAccountId: Clone,
	ConsumerBlockNumber: Default,
	Context: Clone,
{
	fn worst_case(context: Context) -> Self {
		Self {
			provider_head_proof: ProviderHeadStateProof::worst_case(context.clone()),
			dip_commitment_proof: DipCommitmentStateProof::worst_case(context.clone()),
			dip_proof: DidMerkleProof::worst_case(context.clone()),
			signature: TimeBoundDidSignature::worst_case(context),
		}
	}
}

impl<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	ParachainDipDidProof<
		RelayBlockNumber,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	KiltBlockNumber: BenchmarkDefault,
{
	/// Verifies the head data of the state proof for the provider with the
	/// given para ID and relaychain state root.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The head data hashing algorithm used by the relaychain.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof_with_state_root<RelayHasher, ProviderHeader>(
		self,
		provider_para_id: u32,
		relay_state_root: &OutputOf<RelayHasher>,
	) -> Result<
		DipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let provider_head_storage_key = calculate_parachain_head_storage_key(provider_para_id);
		// TODO: Figure out why RPC call returns 2 bytes in front which we don't need
		let provider_header_result = verify_storage_value_proof_with_decoder::<_, RelayHasher, ProviderHeader>(
			&provider_head_storage_key,
			*relay_state_root,
			self.provider_head_proof.proof,
			|input| {
				if input.len() < 2 {
					return None;
				}
				let mut trimmed_input = &input[2..];
				ProviderHeader::decode(&mut trimmed_input).ok()
			},
		);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let provider_header = provider_header_result.unwrap_or_else(|_| ProviderHeader::new(<ProviderHeader as HeaderT>::Number::default(), <ProviderHeader as HeaderT>::Hash::default(), <ProviderHeader as HeaderT>::Hash::default(), <ProviderHeader as HeaderT>::Hash::default(), sp_runtime::Digest::default()));
			} else {
				let provider_header = provider_header_result.map_err(Error::ParaHeadMerkleProof)?;
			}
		}
		Ok(DipDidProofWithVerifiedRelayStateRoot {
			state_root: *provider_header.state_root(),
			dip_commitment_proof: self.dip_commitment_proof,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}

	/// Verifies the head data of the state proof for the provider with the
	/// given para ID using the state root returned by the provided
	/// implementation.
	///
	/// The generic types indicate the following:
	/// * `RelayHasher`: The hashing algorithm used on the relaychain to
	///   generate the parachains head data.
	/// * `StateRootStore`: The type that returns a relaychain state root given
	///   a relaychain block number.
	/// * `ProviderHeader`: The type of the parachain header to be revealed in
	///   the state proof.
	#[allow(clippy::type_complexity)]
	pub fn verify_provider_head_proof<RelayHasher, StateRootStore, ProviderHeader>(
		self,
		provider_para_id: u32,
	) -> Result<
		DipDidProofWithVerifiedRelayStateRoot<
			OutputOf<RelayHasher>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		RelayHasher: Hash,
		StateRootStore: GetWithArg<RelayBlockNumber, Result = Option<OutputOf<RelayHasher>>>,
		ProviderHeader: Decode + HeaderT<Hash = OutputOf<RelayHasher>, Number = KiltBlockNumber>,
	{
		let relay_state_root = StateRootStore::get(&self.provider_head_proof.relay_block_number);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let relay_state_root = relay_state_root.unwrap_or_default();
			} else {
				let relay_state_root = relay_state_root.ok_or(Error::RelayStateRootNotFound)?;
			}
		}
		self.verify_provider_head_proof_with_state_root::<RelayHasher, ProviderHeader>(
			provider_para_id,
			&relay_state_root,
		)
	}
}

/// A DIP proof that has had the proof header and the relaychain state verified
/// for the provided relaychain block number.
///
/// The generic types indicate the following:
/// * `StateRoot`: The type of the relaychain state root.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
#[derive(Debug)]
pub struct DipDidProofWithVerifiedRelayStateRoot<
	StateRoot,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The relaychain state root for the block specified in the DIP proof.
	pub(crate) state_root: StateRoot,
	/// The raw state proof for the DIP commitment of the given subject.
	pub(crate) dip_commitment_proof: DipCommitmentStateProof,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		StateRoot,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	DipDidProofWithVerifiedRelayStateRoot<
		StateRoot,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
{
	/// Verifies the DIP commitment part of the state proof for the subject with
	/// the given identifier.
	///
	/// The generic types indicate the following:
	/// * `ParachainHasher`: The hashing algorithm used to hash storage on the
	///   parachain.
	/// * `ProviderRuntime`: The provider runtime definition.
	#[allow(clippy::type_complexity)]
	pub fn verify_dip_commitment_proof_for_subject<ParachainHasher, ProviderRuntime>(
		self,
		subject: &ProviderRuntime::Identifier,
	) -> Result<
		DipDidProofWithVerifiedSubjectCommitment<
			IdentityCommitmentOf<ProviderRuntime>,
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
		>,
		Error,
	>
	where
		StateRoot: Ord,
		ParachainHasher: Hash<Output = StateRoot>,
		ProviderRuntime: pallet_dip_provider::Config,
		IdentityCommitmentOf<ProviderRuntime>: BenchmarkDefault,
	{
		let dip_commitment_storage_key =
			calculate_dip_identity_commitment_storage_key_for_runtime::<ProviderRuntime>(subject, 0);
		let dip_commitment_result =
			verify_storage_value_proof::<_, ParachainHasher, IdentityCommitmentOf<ProviderRuntime>>(
				&dip_commitment_storage_key,
				self.state_root,
				self.dip_commitment_proof.0,
			);
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let dip_commitment = dip_commitment_result.unwrap_or_default();
			} else {
				let dip_commitment = dip_commitment_result.map_err(Error::DipCommitmentMerkleProof)?;
			}
		}
		Ok(DipDidProofWithVerifiedSubjectCommitment {
			dip_commitment,
			dip_proof: self.dip_proof,
			signature: self.signature,
		})
	}
}

/// A DIP proof that has had the relaychain state and the DIP commitment
/// verified for the provided relaychain block number.
///
/// The generic types indicate the following:
/// * `Commitment`: The DIP identity commitment type configured by the KILT
///   chain.
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
#[derive(Debug)]
pub struct DipDidProofWithVerifiedSubjectCommitment<
	Commitment,
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
> {
	/// The verified DIP identity commitment.
	pub(crate) dip_commitment: Commitment,
	/// The Merkle proof of the subject's DID details.
	pub(crate) dip_proof:
		DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	DipDidProofWithVerifiedSubjectCommitment<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
{
	pub fn new(
		dip_commitment: Commitment,
		dip_proof: DidMerkleProof<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		signature: TimeBoundDidSignature<ConsumerBlockNumber>,
	) -> Self {
		Self {
			dip_commitment,
			dip_proof,
			signature,
		}
	}
}

impl<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	>
	DipDidProofWithVerifiedSubjectCommitment<
		Commitment,
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
	> where
	KiltDidKeyId: Encode,
	KiltAccountId: Encode,
	KiltBlockNumber: Encode,
	KiltWeb3Name: Encode,
	KiltLinkableAccountId: Encode,
{
	/// Verifies the Merkle proof of the subject's DID details.
	///
	/// The generic types indicate the following:
	/// * `DidMerkleHasher`: The hashing algorithm used to merkleize the DID
	///   details.
	/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable
	///   in the proof.
	pub fn verify_dip_proof<DidMerkleHasher, const MAX_REVEALED_LEAVES_COUNT: u32>(
		self,
	) -> Result<
		DipRevealedDetailsAndUnverifiedDidSignature<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			ConsumerBlockNumber,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	>
	where
		DidMerkleHasher: Hash<Output = Commitment>,
	{
		ensure!(
			self.dip_proof.revealed.len() <= MAX_REVEALED_LEAVES_COUNT.saturated_into(),
			Error::TooManyLeavesRevealed
		);

		let proof_leaves_key_value_pairs = self
			.dip_proof
			.revealed
			.iter()
			.map(|revealed_leaf| (revealed_leaf.encoded_key(), Some(revealed_leaf.encoded_value())))
			.collect::<Vec<_>>();
		let proof_verification_result = verify_trie_proof::<LayoutV1<DidMerkleHasher>, _, _, _>(
			&self.dip_commitment,
			self.dip_proof.blinded.as_slice(),
			proof_leaves_key_value_pairs.as_slice(),
		);

		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				drop(proof_verification_result);
			} else {
				proof_verification_result.map_err(|_| Error::InvalidDidMerkleProof)?;
			}
		}
		let revealed_leaves = BoundedVec::try_from(self.dip_proof.revealed).map_err(|_| {
			log::error!("Should not fail to construct BoundedVec since bounds were checked before.");
			Error::Internal
		})?;

		Ok(DipRevealedDetailsAndUnverifiedDidSignature {
			revealed_leaves,
			signature: self.signature,
		})
	}
}

/// A DIP proof whose information has been verified but that contains a
/// cross-chain [`TimeBoundDidSignature`] that still needs verification.
///
/// The generic types indicate the following:
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `ConsumerBlockNumber`: The `BlockNumber` definition of the consumer
///   parachain.
/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable in
///   the proof.
#[derive(Debug)]
pub struct DipRevealedDetailsAndUnverifiedDidSignature<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	ConsumerBlockNumber,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	pub(crate) revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The cross-chain DID signature.
	pub(crate) signature: TimeBoundDidSignature<ConsumerBlockNumber>,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipRevealedDetailsAndUnverifiedDidSignature<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		ConsumerBlockNumber,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	ConsumerBlockNumber: PartialOrd,
{
	/// Verifies that the DIP proof signature is anchored to a block that has
	/// not passed on the consumer chain.
	pub fn verify_signature_time(
		self,
		block_number: &ConsumerBlockNumber,
	) -> Result<
		DipRevealedDetailsAndVerifiedDidSignatureFreshness<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	> {
		cfg_if::cfg_if! {
			if #[cfg(feature = "runtime-benchmarks")] {
				let _ = self.signature.valid_until >= *block_number;
			} else {
				frame_support::ensure!(self.signature.valid_until >= *block_number, Error::InvalidSignatureTime);
			}
		}
		Ok(DipRevealedDetailsAndVerifiedDidSignatureFreshness {
			revealed_leaves: self.revealed_leaves,
			signature: self.signature.signature,
		})
	}
}

/// A DIP proof whose information has been verified and whose signature has been
/// verified not to be expired, but that yet does not contain information as to
/// which of the revealed keys has generated the signature.
///
/// The generic types indicate the following:
/// * `KiltDidKeyId`: The DID key ID type configured by the KILT chain.
/// * `KiltAccountId`: The `AccountId` type configured by the KILT chain.
/// * `KiltBlockNumber`: The `BlockNumber` type configured by the KILT chain.
/// * `KiltWeb3Name`: The web3name type configured by the KILT chain.
/// * `KiltLinkableAccountId`: The linkable account ID type configured by the
///   KILT chain.
/// * `MAX_REVEALED_LEAVES_COUNT`: The maximum number of leaves revealable in
///   the proof.
#[derive(Debug)]
pub struct DipRevealedDetailsAndVerifiedDidSignatureFreshness<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	pub(crate) revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The cross-chain DID signature without time information.
	pub(crate) signature: DidSignature,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipRevealedDetailsAndVerifiedDidSignatureFreshness<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	KiltDidKeyId: BenchmarkDefault,
	KiltBlockNumber: BenchmarkDefault,
{
	/// Iterates over the revealed DID leafs to find the one that generated a
	/// valid signature for the provided payload.
	pub fn retrieve_signing_leaf_for_payload(
		self,
		payload: &[u8],
	) -> Result<
		DipOriginInfo<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
			MAX_REVEALED_LEAVES_COUNT,
		>,
		Error,
	> {
		let revealed_verification_keys = self.revealed_leaves.iter().filter(|leaf| {
			matches!(
				leaf,
				RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey {
					relationship: DidKeyRelationship::Verification(_),
					..
				})
			)
		});
		let maybe_signing_key_index = revealed_verification_keys
			.enumerate()
			.find(|(_, revealed_verification_key)| {
				let RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey {
					details:
						DidPublicKeyDetails {
							key: DidPublicKey::PublicVerificationKey(verification_key),
							..
						},
					..
				}) = revealed_verification_key
				else {
					return false;
				};
				verification_key.verify_signature(payload, &self.signature).is_ok()
			})
			.map(|(index, _)| u32::saturated_from(index));

		let signing_key_entry = if let Some(index) = maybe_signing_key_index {
			(self.revealed_leaves, index)
		} else {
			cfg_if::cfg_if! {
				if #[cfg(feature = "runtime-benchmarks")] {
						return Ok(DipOriginInfo::default());
				} else {
					return Err(Error::InvalidDidKeyRevealed);
				}
			}
		};

		Ok(DipOriginInfo {
			revealed_leaves: signing_key_entry.0,
			signing_leaf_index: signing_key_entry.1,
		})
	}
}

/// Information, available as an origin, after the whole DIP proof has been
/// verified.
#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub struct DipOriginInfo<
	KiltDidKeyId,
	KiltAccountId,
	KiltBlockNumber,
	KiltWeb3Name,
	KiltLinkableAccountId,
	const MAX_REVEALED_LEAVES_COUNT: u32,
> {
	/// The parts of the subject's DID details revealed in the DIP proof.
	revealed_leaves: BoundedVec<
		RevealedDidMerkleProofLeaf<KiltDidKeyId, KiltAccountId, KiltBlockNumber, KiltWeb3Name, KiltLinkableAccountId>,
		ConstU32<MAX_REVEALED_LEAVES_COUNT>,
	>,
	/// The index of the signing leaf from the vector above,
	signing_leaf_index: u32,
}

impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	>
	DipOriginInfo<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	>
{
	/// Returns an iterator over the revealed DID leaves.
	pub fn iter_leaves(
		&self,
	) -> impl Iterator<
		Item = &RevealedDidMerkleProofLeaf<
			KiltDidKeyId,
			KiltAccountId,
			KiltBlockNumber,
			KiltWeb3Name,
			KiltLinkableAccountId,
		>,
	> {
		self.revealed_leaves.iter()
	}

	/// Returns a reference to the leaf that signed the cross-chain operation.
	/// This operation should never fail, so the only error it returns is an
	/// `Error::Internal` which, anyway, should never happen.
	pub fn get_signing_leaf(&self) -> Result<&RevealedDidKey<KiltDidKeyId, KiltBlockNumber, KiltAccountId>, Error> {
		let leaf = &self
			.revealed_leaves
			.get(usize::saturated_from(self.signing_leaf_index))
			.ok_or_else(|| {
				log::error!("Should never fail to retrieve the signing leaf.");
				Error::Internal
			})?;
		let RevealedDidMerkleProofLeaf::DidKey(did_key) = leaf else {
			log::error!("Should never fail to convert the signing leaf to a DID Key leaf.");
			return Err(Error::Internal);
		};
		Ok(did_key)
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		const MAX_REVEALED_LEAVES_COUNT: u32,
	> Default
	for DipOriginInfo<
		KiltDidKeyId,
		KiltAccountId,
		KiltBlockNumber,
		KiltWeb3Name,
		KiltLinkableAccountId,
		MAX_REVEALED_LEAVES_COUNT,
	> where
	KiltDidKeyId: BenchmarkDefault,
	KiltBlockNumber: BenchmarkDefault,
{
	fn default() -> Self {
		let default_keys = sp_std::vec![RevealedDidKey {
			id: KiltDidKeyId::default(),
			details: DidPublicKeyDetails {
				key: did::did_details::DidVerificationKey::Ed25519(sp_core::ed25519::Public::from_raw([0u8; 32]))
					.into(),
				block_number: KiltBlockNumber::default()
			},
			relationship: DidVerificationKeyRelationship::Authentication.into()
		}
		.into()];
		let bounded_keys = default_keys
			.try_into()
			// To avoid requiring types to implement `Debug`.
			.map_err(|_| "Should not fail to convert single element to a BoundedVec.")
			.unwrap();
		Self {
			revealed_leaves: bounded_keys,
			signing_leaf_index: 0u32,
		}
	}
}

/// Relationship of a key to a DID Document.
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord, TypeInfo, MaxEncodedLen)]
pub enum DidKeyRelationship {
	Encryption,
	Verification(DidVerificationKeyRelationship),
}

impl From<DidVerificationKeyRelationship> for DidKeyRelationship {
	fn from(value: DidVerificationKeyRelationship) -> Self {
		Self::Verification(value)
	}
}

impl TryFrom<DidKeyRelationship> for DidVerificationKeyRelationship {
	type Error = ();

	fn try_from(value: DidKeyRelationship) -> Result<Self, Self::Error> {
		if let DidKeyRelationship::Verification(rel) = value {
			Ok(rel)
		} else {
			Err(())
		}
	}
}

/// All possible Merkle leaf types that can be revealed as part of a DIP
/// identity Merkle proof.
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, TypeInfo, MaxEncodedLen)]
pub enum RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> {
	DidKey(RevealedDidKey<KeyId, BlockNumber, AccountId>),
	Web3Name(RevealedWeb3Name<Web3Name, BlockNumber>),
	LinkedAccount(RevealedAccountId<LinkedAccountId>),
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedDidKey<KeyId, BlockNumber, AccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedDidKey<KeyId, BlockNumber, AccountId>) -> Self {
		Self::DidKey(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedWeb3Name<Web3Name, BlockNumber>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedWeb3Name<Web3Name, BlockNumber>) -> Self {
		Self::Web3Name(value)
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> From<RevealedAccountId<LinkedAccountId>>
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
{
	fn from(value: RevealedAccountId<LinkedAccountId>) -> Self {
		Self::LinkedAccount(value)
	}
}

#[cfg(feature = "runtime-benchmarks")]
impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId> Default
	for RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Default,
	BlockNumber: Default,
{
	fn default() -> Self {
		RevealedDidKey {
			id: KeyId::default(),
			relationship: DidVerificationKeyRelationship::Authentication.into(),
			details: DidPublicKeyDetails {
				key: did::did_details::DidVerificationKey::Ed25519(sp_core::ed25519::Public::from_raw([0u8; 32]))
					.into(),
				block_number: BlockNumber::default(),
			},
		}
		.into()
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	KeyId: Encode,
	Web3Name: Encode,
	LinkedAccountId: Encode,
{
	pub fn encoded_key(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { id, relationship, .. }) => (id, relationship).encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { web3_name, .. }) => web3_name.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(RevealedAccountId(account_id)) => account_id.encode(),
		}
	}
}

impl<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
	RevealedDidMerkleProofLeaf<KeyId, AccountId, BlockNumber, Web3Name, LinkedAccountId>
where
	AccountId: Encode,
	BlockNumber: Encode,
{
	pub fn encoded_value(&self) -> Vec<u8> {
		match self {
			RevealedDidMerkleProofLeaf::DidKey(RevealedDidKey { details, .. }) => details.encode(),
			RevealedDidMerkleProofLeaf::Web3Name(RevealedWeb3Name { claimed_at, .. }) => claimed_at.encode(),
			RevealedDidMerkleProofLeaf::LinkedAccount(_) => ().encode(),
		}
	}
}

/// The details of a DID key after it has been successfully verified in a Merkle
/// proof.
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord, TypeInfo, MaxEncodedLen)]
pub struct RevealedDidKey<KeyId, BlockNumber, AccountId> {
	/// The key ID, according to the provider's definition.
	pub id: KeyId,
	/// The key relationship to the subject's DID Document.
	pub relationship: DidKeyRelationship,
	/// The details of the DID Key, including its creation block number on the
	/// provider chain.
	pub details: DidPublicKeyDetails<BlockNumber, AccountId>,
}

/// The details of a web3name after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord, TypeInfo, MaxEncodedLen)]
pub struct RevealedWeb3Name<Web3Name, BlockNumber> {
	/// The web3name.
	pub web3_name: Web3Name,
	/// The block number on the provider chain in which it was linked to the DID
	/// subject.
	pub claimed_at: BlockNumber,
}

/// The details of an account after it has been successfully verified in a
/// Merkle proof.
#[derive(Clone, Copy, Debug, Encode, Decode, PartialEq, Eq, PartialOrd, Ord, TypeInfo, MaxEncodedLen)]
pub struct RevealedAccountId<AccountId>(pub AccountId);
