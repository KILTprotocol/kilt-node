// KILT Blockchain â€“ https://botlabs.org
// Copyright (C) 2019-2024 BOTLabs GmbH

// The KILT Blockchain is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The KILT Blockchain is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// If you feel like getting in touch with us, you can do so at info@botlabs.org

//! # Pallet storing unique nickname <-> DID links for user-friendly DID
//! nicknames.

#![cfg_attr(not(feature = "std"), no_std)]

mod default_weights;

pub mod migrations;
pub mod web3_name;

#[cfg(any(test, feature = "runtime-benchmarks"))]
mod mock;
#[cfg(any(test, feature = "try-runtime"))]
mod try_state;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub use crate::{default_weights::WeightInfo, pallet::*};

#[frame_support::pallet]
// `.expect()` is used in the macro-generated code, and we have to ignore it.
#[allow(clippy::expect_used)]
// `unreachable` is used in the macro-generated code, and we have to ignore it.
#[allow(clippy::unreachable)]
// `ref` keyword is used in the macro-generated code, and we have to ignore it.
#[allow(clippy::ref_patterns)]
// The `pallet::event` macro shadows the `deposit_event` definition of `frame_system::Config`.
// This means we cannot avoid shadow reuses anymore, and for new pallets this `allow` clause should only be added at the
// very end of the development cycle of a pallet, and from time to time it should be commented out to catch any issues
// other than the one generated by the `pallet::event` macro.
#[allow(clippy::shadow_reuse)]
pub mod pallet {
	use frame_support::{
		pallet_prelude::*,
		sp_runtime::SaturatedConversion,
		traits::{
			fungible::{Inspect, InspectHold, MutateHold},
			StorageVersion,
		},
		Blake2_128Concat,
	};
	use frame_system::pallet_prelude::*;
	use parity_scale_codec::FullCodec;
	use sp_runtime::DispatchError;
	use sp_std::{fmt::Debug, vec::Vec};

	use kilt_support::{
		traits::{BalanceMigrationManager, CallSources, StorageDepositCollector},
		Deposit,
	};

	use super::WeightInfo;
	use crate::web3_name::Web3NameOwnership;

	const STORAGE_VERSION: StorageVersion = StorageVersion::new(1);

	pub type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
	pub type BalanceOf<T, I = ()> = <CurrencyOf<T, I> as Inspect<AccountIdOf<T>>>::Balance;
	pub type Web3NameOwnerOf<T, I = ()> = <T as Config<I>>::Web3NameOwner;
	pub type Web3NameInput<T, I = ()> = BoundedVec<u8, <T as Config<I>>::MaxNameLength>;
	pub type Web3NameOf<T, I = ()> = <T as Config<I>>::Web3Name;
	pub type Web3OwnershipOf<T, I = ()> =
		Web3NameOwnership<Web3NameOwnerOf<T, I>, Deposit<AccountIdOf<T>, BalanceOf<T, I>>, BlockNumberFor<T>>;

	pub(crate) type BalanceMigrationManagerOf<T, I> = <T as Config<I>>::BalanceMigrationManager;
	pub(crate) type CurrencyOf<T, I> = <T as Config<I>>::Currency;

	#[pallet::pallet]
	#[pallet::storage_version(STORAGE_VERSION)]
	pub struct Pallet<T, I = ()>(_);

	/// Map of name -> ownership details.
	#[pallet::storage]
	#[pallet::getter(fn owner)]
	pub type Owner<T: Config<I>, I: 'static = ()> =
		StorageMap<_, Blake2_128Concat, Web3NameOf<T, I>, Web3OwnershipOf<T, I>>;

	/// Map of owner -> name.
	#[pallet::storage]
	#[pallet::getter(fn names)]
	pub type Names<T: Config<I>, I: 'static = ()> =
		StorageMap<_, Blake2_128Concat, Web3NameOwnerOf<T, I>, Web3NameOf<T, I>>;

	/// Map of name -> ().
	///
	/// If a name key is present, the name is currently banned.
	#[pallet::storage]
	#[pallet::getter(fn is_banned)]
	pub type Banned<T: Config<I>, I: 'static = ()> = StorageMap<_, Blake2_128Concat, Web3NameOf<T, I>, ()>;

	#[pallet::composite_enum]
	pub enum HoldReason<I: 'static = ()> {
		Deposit,
	}

	#[pallet::config]
	pub trait Config<I: 'static = ()>: frame_system::Config {
		/// The origin allowed to ban names.
		type BanOrigin: EnsureOrigin<Self::RuntimeOrigin>;
		/// The origin allowed to perform regular operations.
		type OwnerOrigin: EnsureOrigin<<Self as frame_system::Config>::RuntimeOrigin, Success = Self::OriginSuccess>;
		/// The type of origin after a successful origin check.
		type OriginSuccess: CallSources<AccountIdOf<Self>, Web3NameOwnerOf<Self, I>>;
		/// Aggregated hold reason.
		type RuntimeHoldReason: From<HoldReason<I>>;
		/// The currency type to reserve and release deposits.
		type Currency: MutateHold<AccountIdOf<Self>, Reason = Self::RuntimeHoldReason>;
		/// The amount of KILT to deposit to claim a name.
		#[pallet::constant]
		type Deposit: Get<BalanceOf<Self, I>>;
		/// The overarching event type.
		type RuntimeEvent: From<Event<Self, I>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
		/// The min encoded length of a name.
		#[pallet::constant]
		type MinNameLength: Get<u32>;
		/// The max encoded length of a name.
		#[pallet::constant]
		type MaxNameLength: Get<u32>;
		// FIXME: Refactor the definition of AsciiWeb3Name so that we don't need to
		// require `Ord` here
		/// The type of a name.
		type Web3Name: FullCodec + Debug + PartialEq + Clone + TypeInfo + TryFrom<Vec<u8>> + MaxEncodedLen + Ord;
		/// The type of a name owner.
		type Web3NameOwner: Parameter + MaxEncodedLen;
		/// Weight information for extrinsics in this pallet.
		type WeightInfo: WeightInfo;

		/// Migration manager to handle new created entries
		type BalanceMigrationManager: BalanceMigrationManager<AccountIdOf<Self>, BalanceOf<Self, I>>;
	}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config<I>, I: 'static = ()> {
		/// A new name has been claimed.
		Web3NameClaimed {
			owner: Web3NameOwnerOf<T, I>,
			name: Web3NameOf<T, I>,
		},
		/// A name has been released.
		Web3NameReleased {
			owner: Web3NameOwnerOf<T, I>,
			name: Web3NameOf<T, I>,
		},
		/// A name has been banned.
		Web3NameBanned { name: Web3NameOf<T, I> },
		/// A name has been unbanned.
		Web3NameUnbanned { name: Web3NameOf<T, I> },
		/// The deposit for a web3name has changed owner.
		DepositOwnerChanged {
			/// The web3name whose deposit owner changed.
			id: Web3NameOf<T, I>,
			/// The old deposit owner.
			from: AccountIdOf<T>,
			/// The new deposit owner.
			to: AccountIdOf<T>,
		},
	}

	#[pallet::error]
	#[derive(PartialEq, Eq)]
	pub enum Error<T, I = ()> {
		/// The tx submitter does not have enough funds to pay for the deposit.
		InsufficientFunds,
		/// The specified name has already been previously claimed.
		AlreadyExists,
		/// The specified name does not exist.
		NotFound,
		/// The specified owner already owns a name.
		OwnerAlreadyExists,
		/// The specified owner does not own any names.
		OwnerNotFound,
		/// The specified name has been banned and cannot be interacted
		/// with.
		Banned,
		/// The specified name is not currently banned.
		NotBanned,
		/// The specified name has already been previously banned.
		AlreadyBanned,
		/// The actor cannot performed the specified operation.
		NotAuthorized,
		/// A name that is too short is being claimed.
		TooShort,
		/// A name that is too long is being claimed.
		TooLong,
		/// A name that contains not allowed characters is being claimed.
		InvalidCharacter,
	}

	#[pallet::hooks]
	impl<T: Config<I>, I: 'static> Hooks<BlockNumberFor<T>> for Pallet<T, I> {
		#[cfg(feature = "try-runtime")]
		fn try_state(_n: BlockNumberFor<T>) -> Result<(), sp_runtime::TryRuntimeError> {
			crate::try_state::do_try_state::<T, I>()
		}
	}

	#[pallet::call]
	impl<T: Config<I>, I: 'static> Pallet<T, I>
	where
		// We introduce this trait bound instead of adding one more generic.
		<<T as Config<I>>::Web3Name as TryFrom<Vec<u8>>>::Error: Into<Error<T, I>>,
	{
		/// Assign the specified name to the owner as specified in the
		/// origin.
		///
		/// The name must not have already been claimed by someone else and the
		/// owner must not already own another name.
		///
		/// Emits `Web3NameClaimed` if the operation is carried out
		/// successfully.
		///
		/// # <weight>
		/// Weight: O(1)
		/// - Reads: Names, Owner, Banned storage entries + available currency
		///   check + origin check
		/// - Writes: Names, Owner storage entries + currency deposit reserve
		/// # </weight>
		#[pallet::call_index(0)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::claim(name.len().saturated_into()))]
		pub fn claim(origin: OriginFor<T>, name: Web3NameInput<T, I>) -> DispatchResult {
			let runtime_origin = T::OwnerOrigin::ensure_origin(origin)?;
			let payer = runtime_origin.sender();
			let owner = runtime_origin.subject();

			let decoded_name = Self::check_claiming_preconditions(name, &owner, &payer)?;

			Self::register_name(decoded_name, owner, payer)?;

			Ok(())
		}

		/// Release the provided name from its owner.
		///
		/// The origin must be the owner of the specified name.
		///
		/// Emits `Web3NameReleased` if the operation is carried out
		/// successfully.
		///
		/// # <weight>
		/// Weight: O(1)
		/// - Reads: Names storage entry + origin check
		/// - Writes: Names, Owner storage entries + currency deposit release
		/// # </weight>
		#[pallet::call_index(1)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::release_by_owner())]
		pub fn release_by_owner(origin: OriginFor<T>) -> DispatchResult {
			let runtime_origin = T::OwnerOrigin::ensure_origin(origin)?;
			let owner = runtime_origin.subject();

			let owned_name = Self::check_releasing_preconditions(&owner)?;

			Self::unregister_name(&owned_name)?;

			Ok(())
		}

		/// Release the provided name from its owner.
		///
		/// The origin must be the account that paid for the name's deposit.
		///
		/// Emits `Web3NameReleased` if the operation is carried out
		/// successfully.
		///
		/// # <weight>
		/// Weight: O(1)
		/// - Reads: Owner storage entry + origin check
		/// - Writes: Names, Owner storage entries + currency deposit release
		/// # </weight>
		#[pallet::call_index(2)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::reclaim_deposit(name.len().saturated_into()))]
		pub fn reclaim_deposit(origin: OriginFor<T>, name: Web3NameInput<T, I>) -> DispatchResult {
			let caller = ensure_signed(origin)?;

			let decoded_name = Self::check_reclaim_deposit_preconditions(name, &caller)?;

			Self::unregister_name(&decoded_name)?;

			Ok(())
		}

		/// Ban a name.
		///
		/// A banned name cannot be claimed by anyone. The name's deposit
		/// is returned to the original payer.
		///
		/// The origin must be the ban origin.
		///
		/// Emits `Web3NameBanned` if the operation is carried out
		/// successfully.
		///
		/// # <weight>
		/// Weight: O(1)
		/// - Reads: Banned, Owner, Names storage entries + origin check
		/// - Writes: Names, Owner, Banned storage entries + currency deposit
		///   release
		/// # </weight>
		#[pallet::call_index(3)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::ban(name.len().saturated_into()))]
		pub fn ban(origin: OriginFor<T>, name: Web3NameInput<T, I>) -> DispatchResult {
			T::BanOrigin::ensure_origin(origin)?;

			let (decoded_name, is_claimed) = Self::check_banning_preconditions(name)?;

			if is_claimed {
				Self::unregister_name(&decoded_name)?;
			}

			Self::ban_name(&decoded_name);
			Self::deposit_event(Event::<T, I>::Web3NameBanned { name: decoded_name });

			Ok(())
		}

		/// Unban a name.
		///
		/// Make a name claimable again.
		///
		/// The origin must be the ban origin.
		///
		/// Emits `Web3NameUnbanned` if the operation is carried out
		/// successfully.
		///
		/// # <weight>
		/// Weight: O(1)
		/// - Reads: Banned storage entry + origin check
		/// - Writes: Banned storage entry deposit release
		/// # </weight>
		#[pallet::call_index(4)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::unban(name.len().saturated_into()))]
		pub fn unban(origin: OriginFor<T>, name: Web3NameInput<T, I>) -> DispatchResult {
			T::BanOrigin::ensure_origin(origin)?;

			let decoded_name = Self::check_unbanning_preconditions(name)?;

			Self::unban_name(&decoded_name);
			Self::deposit_event(Event::<T, I>::Web3NameUnbanned { name: decoded_name });

			Ok(())
		}

		/// Changes the deposit owner.
		///
		/// The balance that is reserved by the current deposit owner will be
		/// freed and balance of the new deposit owner will get reserved.
		///
		/// The subject of the call must be the owner of the web3name.
		/// The sender of the call will be the new deposit owner.
		#[pallet::call_index(5)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::change_deposit_owner())]
		pub fn change_deposit_owner(origin: OriginFor<T>) -> DispatchResult {
			let source = <T as Config<I>>::OwnerOrigin::ensure_origin(origin)?;
			let w3n_owner = source.subject();
			let sender = source.sender();
			let name = Names::<T, I>::get(&w3n_owner).ok_or(Error::<T, I>::NotFound)?;

			let old_deposit_owner = Web3NameStorageDepositCollector::<T, I>::change_deposit_owner::<
				BalanceMigrationManagerOf<T, I>,
			>(&name, sender.clone())?;

			Self::deposit_event(Event::<T, I>::DepositOwnerChanged {
				id: name,
				from: old_deposit_owner,
				to: sender,
			});

			Ok(())
		}

		/// Updates the deposit amount to the current deposit rate.
		///
		/// The sender must be the deposit owner.
		#[pallet::call_index(6)]
		#[pallet::weight(<T as Config<I>>::WeightInfo::update_deposit())]
		pub fn update_deposit(origin: OriginFor<T>, name_input: Web3NameInput<T, I>) -> DispatchResult {
			let source = ensure_signed(origin)?;
			let name =
				Web3NameOf::<T, I>::try_from(name_input.into_inner()).map_err(|e| DispatchError::from(e.into()))?;
			let w3n_entry = Owner::<T, I>::get(&name).ok_or(Error::<T, I>::NotFound)?;
			ensure!(w3n_entry.deposit.owner == source, Error::<T, I>::NotAuthorized);

			Web3NameStorageDepositCollector::<T, I>::update_deposit::<BalanceMigrationManagerOf<T, I>>(&name)?;

			Ok(())
		}
	}

	impl<T: Config<I>, I: 'static> Pallet<T, I>
	where
		<<T as Config<I>>::Web3Name as TryFrom<Vec<u8>>>::Error: Into<Error<T, I>>,
	{
		/// Verify that the claiming preconditions are verified. Specifically:
		/// - The name input data can be decoded as a valid name
		/// - The name does not already exist
		/// - The owner does not already own a name
		/// - The name has not been banned
		/// - The tx submitter has enough funds to pay the deposit
		fn check_claiming_preconditions(
			name_input: Web3NameInput<T, I>,
			owner: &Web3NameOwnerOf<T, I>,
			deposit_payer: &AccountIdOf<T>,
		) -> Result<Web3NameOf<T, I>, DispatchError> {
			let name =
				Web3NameOf::<T, I>::try_from(name_input.into_inner()).map_err(|e| DispatchError::from(e.into()))?;

			ensure!(!Names::<T, I>::contains_key(owner), Error::<T, I>::OwnerAlreadyExists);
			ensure!(!Owner::<T, I>::contains_key(&name), Error::<T, I>::AlreadyExists);
			ensure!(!Banned::<T, I>::contains_key(&name), Error::<T, I>::Banned);

			ensure!(
				<T::Currency as InspectHold<AccountIdOf<T>>>::can_hold(
					&HoldReason::Deposit.into(),
					deposit_payer,
					T::Deposit::get()
				),
				Error::<T, I>::InsufficientFunds
			);

			Ok(name)
		}

		/// Assign a name to the provided owner reserving the deposit from
		/// the provided account. This function must be called after
		/// `check_claiming_preconditions` as it does not verify all the
		/// preconditions again.
		pub fn register_name(
			name: Web3NameOf<T, I>,
			owner: Web3NameOwnerOf<T, I>,
			deposit_payer: AccountIdOf<T>,
		) -> DispatchResult {
			let block_number = frame_system::Pallet::<T>::block_number();

			let deposit = Web3NameStorageDepositCollector::<T, I>::create_deposit(deposit_payer, T::Deposit::get())?;
			<T as Config<I>>::BalanceMigrationManager::exclude_key_from_migration(&Owner::<T, I>::hashed_key_for(
				&name,
			));

			Names::<T, I>::insert(&owner, name.clone());
			Owner::<T, I>::insert(
				&name,
				Web3OwnershipOf::<T, I> {
					owner: owner.clone(),
					claimed_at: block_number,
					deposit,
				},
			);

			Self::deposit_event(Event::<T, I>::Web3NameClaimed { owner, name });
			Ok(())
		}

		/// Verify that the releasing preconditions for an owner are verified.
		/// Specifically:
		/// - The owner has a previously claimed name
		fn check_releasing_preconditions(owner: &Web3NameOwnerOf<T, I>) -> Result<Web3NameOf<T, I>, DispatchError> {
			let name = Names::<T, I>::get(owner).ok_or(Error::<T, I>::OwnerNotFound)?;

			Ok(name)
		}

		/// Verify that the releasing preconditions for a deposit payer are
		/// verified. Specifically:
		/// - The name input data can be decoded as a valid name
		/// - The name exists (i.e., it has been previous claimed)
		/// - The caller owns the name's deposit
		fn check_reclaim_deposit_preconditions(
			name_input: Web3NameInput<T, I>,
			caller: &AccountIdOf<T>,
		) -> Result<Web3NameOf<T, I>, DispatchError> {
			let name =
				Web3NameOf::<T, I>::try_from(name_input.into_inner()).map_err(|e| DispatchError::from(e.into()))?;
			let Web3NameOwnership { deposit, .. } = Owner::<T, I>::get(&name).ok_or(Error::<T, I>::NotFound)?;

			ensure!(caller == &deposit.owner, Error::<T, I>::NotAuthorized);

			Ok(name)
		}

		/// Release the provided name and returns the deposit to the
		/// original payer. This function must be called after
		/// `check_releasing_preconditions` as it does not verify all the
		/// preconditions again.
		fn unregister_name(name: &Web3NameOf<T, I>) -> Result<Web3OwnershipOf<T, I>, DispatchError> {
			let name_ownership = Owner::<T, I>::take(name).ok_or(Error::<T, I>::OwnerNotFound)?;
			Names::<T, I>::remove(&name_ownership.owner);

			let is_key_migrated =
				<T as Config<I>>::BalanceMigrationManager::is_key_migrated(&Owner::<T, I>::hashed_key_for(name));

			if is_key_migrated {
				Web3NameStorageDepositCollector::<T, I>::free_deposit(name_ownership.clone().deposit)?;
			} else {
				<T as Config<I>>::BalanceMigrationManager::release_reserved_deposit(
					&name_ownership.deposit.owner,
					&name_ownership.deposit.amount,
				)
			}

			Self::deposit_event(Event::<T, I>::Web3NameReleased {
				owner: name_ownership.owner.clone(),
				name: name.clone(),
			});

			Ok(name_ownership)
		}

		/// Verify that the banning preconditions are verified.
		/// Specifically:
		/// - The name input data can be decoded as a valid name
		/// - The name must not be already banned
		///
		/// If the preconditions are verified, return
		/// a tuple containing the parsed name value and whether the name
		/// being banned is currently assigned to someone or not.
		fn check_banning_preconditions(
			name_input: Web3NameInput<T, I>,
		) -> Result<(Web3NameOf<T, I>, bool), DispatchError> {
			let name =
				Web3NameOf::<T, I>::try_from(name_input.into_inner()).map_err(|e| DispatchError::from(e.into()))?;

			ensure!(!Banned::<T, I>::contains_key(&name), Error::<T, I>::AlreadyBanned);

			let is_claimed = Owner::<T, I>::contains_key(&name);

			Ok((name, is_claimed))
		}

		/// Ban the provided name. This function must be called after
		/// `check_banning_preconditions` as it does not verify all the
		/// preconditions again.
		pub(crate) fn ban_name(name: &Web3NameOf<T, I>) {
			Banned::<T, I>::insert(name, ());
		}

		/// Verify that the unbanning preconditions are verified.
		/// Specifically:
		/// - The name input data can be decoded as a valid name
		/// - The name must have already been banned
		fn check_unbanning_preconditions(name_input: Web3NameInput<T, I>) -> Result<Web3NameOf<T, I>, DispatchError> {
			let name =
				Web3NameOf::<T, I>::try_from(name_input.into_inner()).map_err(|e| DispatchError::from(e.into()))?;

			ensure!(Banned::<T, I>::contains_key(&name), Error::<T, I>::NotBanned);

			Ok(name)
		}

		/// Unban the provided name. This function must be called after
		/// `check_unbanning_preconditions` as it does not verify all the
		/// preconditions again.
		fn unban_name(name: &Web3NameOf<T, I>) {
			Banned::<T, I>::remove(name);
		}
	}

	pub(crate) struct Web3NameStorageDepositCollector<T, I>(PhantomData<(T, I)>);
	impl<T: Config<I>, I: 'static>
		StorageDepositCollector<AccountIdOf<T>, <T as Config<I>>::Web3Name, <T as Config<I>>::RuntimeHoldReason>
		for Web3NameStorageDepositCollector<T, I>
	{
		type Currency = T::Currency;
		type Reason = HoldReason<I>;

		fn get_hashed_key(key: &T::Web3Name) -> Result<sp_std::vec::Vec<u8>, DispatchError> {
			Ok(Owner::<T, I>::hashed_key_for(key))
		}

		fn reason() -> Self::Reason {
			HoldReason::Deposit
		}
		fn deposit(
			key: &T::Web3Name,
		) -> Result<Deposit<AccountIdOf<T>, <Self::Currency as Inspect<AccountIdOf<T>>>::Balance>, DispatchError> {
			let w3n_entry = Owner::<T, I>::get(key).ok_or(Error::<T, I>::NotFound)?;

			Ok(w3n_entry.deposit)
		}

		fn deposit_amount(_key: &T::Web3Name) -> <Self::Currency as Inspect<AccountIdOf<T>>>::Balance {
			T::Deposit::get()
		}

		fn store_deposit(
			key: &T::Web3Name,
			deposit: Deposit<AccountIdOf<T>, <Self::Currency as Inspect<AccountIdOf<T>>>::Balance>,
		) -> Result<(), DispatchError> {
			let w3n_entry = Owner::<T, I>::get(key).ok_or(Error::<T, I>::NotFound)?;
			Owner::<T, I>::insert(key, Web3OwnershipOf::<T, I> { deposit, ..w3n_entry });

			Ok(())
		}
	}
}
